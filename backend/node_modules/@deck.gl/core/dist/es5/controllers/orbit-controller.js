"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _orbitViewport = _interopRequireDefault(require("../deprecated/orbit-viewport"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ZOOM_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(['zoom']),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};
var defaultState = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationOrbit: 0,
  fov: 50,
  near: 1,
  far: 100,
  translationX: 0,
  translationY: 0,
  zoom: 1
};
var defaultConstraints = {
  minZoom: 0,
  maxZoom: Infinity
};
/* Helpers */

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var OrbitState =
/*#__PURE__*/
function () {
  function OrbitState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        distance = _ref.distance,
        rotationX = _ref.rotationX,
        rotationOrbit = _ref.rotationOrbit,
        orbitAxis = _ref.orbitAxis,
        bounds = _ref.bounds,
        lookAt = _ref.lookAt,
        fov = _ref.fov,
        near = _ref.near,
        far = _ref.far,
        translationX = _ref.translationX,
        translationY = _ref.translationY,
        zoom = _ref.zoom,
        minZoom = _ref.minZoom,
        maxZoom = _ref.maxZoom,
        startPanViewport = _ref.startPanViewport,
        startPanPos = _ref.startPanPos,
        isPanning = _ref.isPanning,
        startRotateViewport = _ref.startRotateViewport,
        isRotating = _ref.isRotating,
        startZoomViewport = _ref.startZoomViewport,
        startZoomPos = _ref.startZoomPos;

    _classCallCheck(this, OrbitState);

    (0, _assert.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert.default)(Number.isFinite(height), '`height` must be supplied');
    (0, _assert.default)(Number.isFinite(distance), '`distance` must be supplied');
    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      distance: distance,
      rotationX: ensureFinite(rotationX, defaultState.rotationX),
      rotationOrbit: ensureFinite(rotationOrbit, defaultState.rotationOrbit),
      orbitAxis: orbitAxis,
      bounds: bounds,
      lookAt: lookAt || defaultState.lookAt,
      fov: ensureFinite(fov, defaultState.fov),
      near: ensureFinite(near, defaultState.near),
      far: ensureFinite(far, defaultState.far),
      translationX: ensureFinite(translationX, defaultState.translationX),
      translationY: ensureFinite(translationY, defaultState.translationY),
      zoom: ensureFinite(zoom, defaultState.zoom),
      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),
      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)
    });
    this._interactiveState = {
      startPanViewport: startPanViewport,
      startPanPos: startPanPos,
      isPanning: isPanning,
      startRotateViewport: startRotateViewport,
      isRotating: isRotating,
      startZoomViewport: startZoomViewport,
      startZoomPos: startZoomPos
    };
  }
  /* Public API */


  _createClass(OrbitState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var viewport = new _orbitViewport.default(this._viewportProps);
      return this._getUpdatedOrbitState({
        startPanPos: pos,
        startPanViewport: viewport
      });
    }
    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      if (this._interactiveState.isRotating) {
        return this._getUpdatedOrbitState();
      }

      var startPanPos = this._interactiveState.startPanPos || startPos;
      (0, _assert.default)(startPanPos, '`startPanPos` props is required');
      var viewport = this._interactiveState.startPanViewport || new _orbitViewport.default(this._viewportProps);
      var deltaX = pos[0] - startPanPos[0];
      var deltaY = pos[1] - startPanPos[1];
      var center = viewport.project(viewport.lookAt);
      var newLookAt = viewport.unproject([center[0] - deltaX, center[1] - deltaY, center[2]]);
      return this._getUpdatedOrbitState({
        lookAt: newLookAt,
        isPanning: true
      });
    }
    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedOrbitState({
        startPanViewport: null,
        startPanPos: null,
        isPanning: null
      });
    }
    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      // Rotation center should be the worldspace position at the center of the
      // the screen. If not found, use the last one.
      var viewport = new _orbitViewport.default(this._viewportProps);
      return this._getUpdatedOrbitState({
        startRotateViewport: viewport
      });
    }
    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;

      if (this._interactiveState.isPanning) {
        return this._getUpdatedOrbitState();
      }

      var startRotateViewport = this._interactiveState.startRotateViewport;

      var _ref6 = startRotateViewport || {},
          rotationX = _ref6.rotationX,
          rotationOrbit = _ref6.rotationOrbit;

      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);
      rotationOrbit = ensureFinite(rotationOrbit, this._viewportProps.rotationOrbit);
      var newRotationX = (0, _math.clamp)(rotationX - deltaScaleY * 180, -89.999, 89.999);
      var newRotationOrbit = (rotationOrbit - deltaScaleX * 180) % 360;
      return this._getUpdatedOrbitState({
        rotationX: newRotationX,
        rotationOrbit: newRotationOrbit,
        isRotating: true
      });
    }
    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedOrbitState({
        startRotateViewport: null,
        isRotating: null
      });
    } // default implementation of shortest path between two view states

  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      var props = Object.assign({}, this._viewportProps);
      return props;
    }
    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: "zoomStart",
    value: function zoomStart(_ref7) {
      var pos = _ref7.pos;
      var viewport = new _orbitViewport.default(this._viewportProps);
      return this._getUpdatedOrbitState({
        startZoomViewport: viewport,
        startZoomPos: pos
      });
    }
    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: "zoom",
    value: function zoom(_ref8) {
      var pos = _ref8.pos,
          startPos = _ref8.startPos,
          scale = _ref8.scale;
      var _this$_viewportProps = this._viewportProps,
          zoom = _this$_viewportProps.zoom,
          minZoom = _this$_viewportProps.minZoom,
          maxZoom = _this$_viewportProps.maxZoom,
          width = _this$_viewportProps.width,
          height = _this$_viewportProps.height;
      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;
      var viewport = this._interactiveState.startZoomViewport || new _orbitViewport.default(this._viewportProps);
      var newZoom = (0, _math.clamp)(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1]; // Zoom around the center position

      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var center = viewport.project(viewport.lookAt);
      var newCenterX = center[0] - cx + cx * newZoom / zoom + deltaX;
      var newCenterY = center[1] + cy - cy * newZoom / zoom - deltaY;
      var newLookAt = viewport.unproject([newCenterX, newCenterY, center[2]]);
      return this._getUpdatedOrbitState({
        lookAt: newLookAt,
        zoom: newZoom
      });
    }
    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedOrbitState({
        startZoomPos: null
      });
    }
    /* Private methods */

  }, {
    key: "_getUpdatedOrbitState",
    value: function _getUpdatedOrbitState(newProps) {
      // Update _viewportProps
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    } // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;
      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;
      return props;
    }
  }]);

  return OrbitState;
}();

var OrbitController =
/*#__PURE__*/
function (_Controller) {
  _inherits(OrbitController, _Controller);

  function OrbitController(props) {
    _classCallCheck(this, OrbitController);

    return _possibleConstructorReturn(this, _getPrototypeOf(OrbitController).call(this, OrbitState, props));
  }

  _createClass(OrbitController, [{
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      // Enable transitions for zoom change
      return ZOOM_TRANSITION_PROPS;
    }
  }]);

  return OrbitController;
}(_controller.default);

exports.default = OrbitController;
//# sourceMappingURL=orbit-controller.js.map