"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attribute = _interopRequireDefault(require("./attribute"));

var _log = _interopRequireDefault(require("../utils/log"));

var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LOG_START_END_PRIORITY = 2;
var LOG_DETAIL_PRIORITY = 3;

function noop() {} // Default loggers


var logFunctions = {
  savedMessages: null,
  timeStart: null,
  onLog: function onLog(_ref) {
    var level = _ref.level,
        message = _ref.message;

    _log.default.log(level, message)();
  },
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        numInstances = _ref2.numInstances;
    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: function onUpdate(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;
    var timeMs = Math.round(new Date() - logFunctions.timeStart);
    var time = "".concat(timeMs, "ms");

    _log.default.group(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time), {
      collapsed: true
    })();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var message = _step.value;

        _log.default.log(level, message)();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _log.default.groupEnd(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time))();

    logFunctions.savedMessages = null;
  }
};

var AttributeManager =
/*#__PURE__*/
function () {
  _createClass(AttributeManager, null, [{
    key: "setDefaultLogFunctions",

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [onLog=] - called to print
     * @param {String} [onUpdateStart=] - called before update() starts
     * @param {String} [onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdate = _ref5.onUpdate,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }

      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }

      if (onUpdate !== undefined) {
        logFunctions.onUpdate = onUpdate || noop;
      }

      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }
    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     */

  }]);

  function AttributeManager(gl) {
    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,
        stats = _ref6.stats;

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions")
    }); // For debugging sanity, prevent uninitialized members

    Object.seal(this);
  }

  _createClass(AttributeManager, [{
    key: "finalize",
    value: function finalize() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }

      this.attributeTransitionManager.finalize();
    } // Returns the redraw flag, optionally clearing it.
    // Redraw flag will be set if any attributes attributes changed since
    // flag was last cleared.
    //
    // @param {String} [clearRedrawFlags=false] - whether to clear the flag
    // @return {false|String} - reason a redraw is needed.

  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
          clearRedrawFlags = _ref7$clearRedrawFlag === void 0 ? false : _ref7$clearRedrawFlag;

      var redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw && this.id;
    } // Sets the redraw flag.
    // @param {Boolean} redraw=true
    // @return {AttributeManager} - for chaining

  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.needsRedraw = true;
      return this;
    } // Adds attributes

  }, {
    key: "add",
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    } // Adds attributes

  }, {
    key: "addInstanced",
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, {
        instanced: 1
      });
    }
    /**
     * Removes attributes
     * Takes an array of attribute names and delete them from
     * the attribute map if they exists
     *
     * @example
     * attributeManager.remove(['position']);
     *
     * @param {Object} attributeNameArray - attribute name array (see above)
     */

  }, {
    key: "remove",
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];

        if (this.attributes[name] !== undefined) {
          this.attributes[name].delete();
          delete this.attributes[name];
        }
      }
    } // Marks an attribute for update

  }, {
    key: "invalidate",
    value: function invalidate(triggerName) {
      var invalidatedAttributes = this._invalidateTrigger(triggerName); // For performance tuning


      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated attributes ".concat(invalidatedAttributes, " (").concat(triggerName, ") for ").concat(this.id)
      });
    }
  }, {
    key: "invalidateAll",
    value: function invalidateAll() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate();
      } // For performance tuning


      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated all attributes for ".concat(this.id)
      });
    } // Ensure all attribute buffers are updated from props or data.

  }, {
    key: "update",
    value: function update() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref8.data,
          numInstances = _ref8.numInstances,
          transitions = _ref8.transitions,
          _ref8$props = _ref8.props,
          props = _ref8$props === void 0 ? {} : _ref8$props,
          _ref8$buffers = _ref8.buffers,
          buffers = _ref8$buffers === void 0 ? {} : _ref8$buffers,
          _ref8$context = _ref8.context,
          context = _ref8$context === void 0 ? {} : _ref8$context;

      // keep track of whether some attributes are updated
      var updated = false;
      logFunctions.onUpdateStart({
        level: LOG_START_END_PRIORITY,
        id: this.id,
        numInstances: numInstances
      });

      if (this.stats) {
        this.stats.timeStart('attribute updates', this.id);
      }

      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName];

        if (attribute.setExternalBuffer(buffers[attributeName], this.numInstances)) {// Attribute is using external buffer from the props
        } else if (attribute.setGenericValue(props[attribute.getAccessor()])) {// Attribute is using generic value from the props
        } else if (attribute.needsUpdate()) {
          updated = true;

          this._updateAttribute({
            attribute: attribute,
            numInstances: numInstances,
            data: data,
            props: props,
            context: context
          });
        }

        this.needsRedraw |= attribute.needsRedraw();
      }

      if (updated) {
        // Only initiate alloc/update (and logging) if actually needed
        if (this.stats) {
          this.stats.timeEnd('attribute updates', this.id);
        }

        logFunctions.onUpdateEnd({
          level: LOG_START_END_PRIORITY,
          id: this.id,
          numInstances: numInstances
        });
      }

      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances: numInstances,
        transitions: transitions
      });
    } // Update attribute transition to the current timestamp
    // Returns `true` if any transition is in progress

  }, {
    key: "updateTransition",
    value: function updateTransition() {
      var attributeTransitionManager = this.attributeTransitionManager;
      var transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: "getChangedAttributes",
    value: function getChangedAttributes(_ref9) {
      var _ref9$clearChangedFla = _ref9.clearChangedFlags,
          clearChangedFlags = _ref9$clearChangedFla === void 0 ? false : _ref9$clearChangedFla;
      var attributes = this.attributes,
          attributeTransitionManager = this.attributeTransitionManager;
      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute.needsRedraw({
          clearChangedFlags: true
        })) {
          // Only return non-transition attributes
          if (!attributeTransitionManager.hasAttribute(attributeName)) {
            changedAttributes[attributeName] = attribute;
          }
        }
      }

      return changedAttributes;
    } // PROTECTED METHODS - Only to be used by collaborating classes, not by apps
    // Returns object containing all accessors as keys, with non-null values
    // @return {Object} - accessors object

  }, {
    key: "getAccessors",
    value: function getAccessors() {
      return this.updateTriggers;
    } // PRIVATE METHODS
    // Used to register an attribute

  }, {
    key: "_add",
    value: function _add(attributes, updaters) {
      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (updaters) {
        _log.default.removed('AttributeManager.add({updaters}) - updater map no longer supported');
      }

      var newAttributes = {};

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName]; // Initialize the attribute descriptor, with WebGL and metadata fields

        newAttributes[attributeName] = new _attribute.default(this.gl, Object.assign({}, attribute, {
          id: attributeName,
          // Luma fields
          constant: attribute.constant || false,
          isIndexed: attribute.isIndexed || attribute.elements,
          size: attribute.elements && 1 || attribute.size,
          value: attribute.value || null,
          instanced: attribute.instanced || extraProps.instanced
        }));
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }
    /* eslint-enable max-statements */
    // build updateTrigger name to attribute name mapping

  }, {
    key: "_mapUpdateTriggersToAttributes",
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach(function (triggerName) {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }

          triggers[triggerName].push(attributeName);
        });
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: "_invalidateTrigger",
    value: function _invalidateTrigger(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;
      var invalidatedAttributes = updateTriggers[triggerName];

      if (invalidatedAttributes) {
        invalidatedAttributes.forEach(function (name) {
          var attribute = attributes[name];

          if (attribute) {
            attribute.setNeedsUpdate();
          }
        });
      } else {
        var message = "invalidating non-existent trigger ".concat(triggerName, " for ").concat(this.id, "\n");
        message += "Valid triggers: ".concat(Object.keys(attributes).join(', '));

        _log.default.warn(message, invalidatedAttributes)();
      }

      return invalidatedAttributes;
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(_ref10) {
      var attribute = _ref10.attribute,
          numInstances = _ref10.numInstances,
          data = _ref10.data,
          props = _ref10.props,
          context = _ref10.context;

      if (attribute.allocate(numInstances)) {
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " allocated ").concat(numInstances),
          id: this.id
        });
      } // Calls update on any buffers that need update


      var timeStart = Date.now();
      var updated = attribute.updateBuffer({
        numInstances: numInstances,
        data: data,
        props: props,
        context: context
      });

      if (updated) {
        this.needsRedraw = true;
        var timeMs = Math.round(Date.now() - timeStart);
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms")
        });
      }
    }
  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=attribute-manager.js.map