"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layerManager = _interopRequireDefault(require("./layer-manager"));

var _viewManager = _interopRequireDefault(require("./view-manager"));

var _mapView = _interopRequireDefault(require("../views/map-view"));

var _effectManager = _interopRequireDefault(require("../experimental/lib/effect-manager"));

var _effect = _interopRequireDefault(require("../experimental/lib/effect"));

var _log = _interopRequireDefault(require("../utils/log"));

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _probe = require("probe.gl");

var _mjolnir = require("mjolnir.js");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _cssVendorPrefix = _interopRequireDefault(require("../utils/css-vendor-prefix"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* global document */
function noop() {}

var PREFIX = _cssVendorPrefix.default === '-webkit-' ? _cssVendorPrefix.default : '';
var CURSOR = {
  GRABBING: "".concat(PREFIX, "grabbing"),
  GRAB: "".concat(PREFIX, "grab"),
  POINTER: 'pointer'
};

var getCursor = function getCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
};

function getPropTypes(PropTypes) {
  // Note: Arrays (layers, views, ) can contain falsy values
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    // layer/view/controller settings
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
    // GL settings
    gl: PropTypes.object,
    glOptions: PropTypes.object,
    parameters: PropTypes.object,
    pickingRadius: PropTypes.number,
    useDevicePixels: PropTypes.bool,
    // Callbacks
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onViewStateChange: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLayerClick: PropTypes.func,
    onLayerHover: PropTypes.func,
    onLoad: PropTypes.func,
    // Debug settings
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool,
    // Experimental props
    // Forces a redraw every animation frame
    _animate: PropTypes.bool
  };
}

var defaultProps = {
  id: 'deckgl-overlay',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: true,
  _animate: false,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null,
  onLoad: noop,
  getCursor: getCursor,
  debug: false,
  drawPickingColors: false
};

var Deck =
/*#__PURE__*/
function () {
  function Deck(props) {
    _classCallCheck(this, Deck);

    props = Object.assign({}, defaultProps, props);
    this.width = 0; // "read-only", auto-updated from canvas

    this.height = 0; // "read-only", auto-updated from canvas
    // Maps view descriptors to vieports, rebuilds when width/height/viewState/views change

    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.stats = new _probe.Stats({
      id: 'deck.gl'
    });
    this._needsRedraw = true;
    this.viewState = props.initialViewState || null; // Internal view state if no callback is supplied

    this.interactiveState = {
      isDragging: false // Whether the cursor is down

    }; // Bind methods

    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);
    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);
    this._onViewStateChange = this._onViewStateChange.bind(this);
    this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this);

    if (!props._customRender) {
      // Note: LayerManager creation deferred until gl context available
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }

      this.animationLoop = this._createAnimationLoop(props);
    }

    this.setProps(props);

    if (!props._customRender) {
      this.animationLoop.start();
    }
  }

  _createClass(Deck, [{
    key: "finalize",
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }

      if (this.viewManager) {
        this.viewManager.finalize();
        this.viewManager = null;
      }

      if (this.eventManager) {
        this.eventManager.destroy();
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.stats.timeStart('deck.setProps');
      props = Object.assign({}, this.props, props);
      this.props = props; // Update CSS size of canvas

      this._setCanvasSize(props); // We need to overwrite CSS style width and height with actual, numeric values


      var newProps = Object.assign({}, props, {
        views: this._getViews(props),
        width: this.width,
        height: this.height
      });

      var viewState = this._getViewState(props);

      if (viewState) {
        newProps.viewState = viewState;
      } // Update view manager props


      if (this.viewManager) {
        this.viewManager.setProps(newProps);
      } // Update layer manager props (but not size)


      if (this.layerManager) {
        this.layerManager.setProps(newProps);
      } // Update animation loop


      if (this.animationLoop) {
        this.animationLoop.setProps(newProps);
      }

      this.stats.timeEnd('deck.setProps');
    } // Public API
    // Check if a redraw is needed
    // Returns `false` or a string summarizing the redraw reason

  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? true : _ref2$clearRedrawFlag;

      if (this.props._animate) {
        return 'Deck._animate';
      }

      var redraw = this._needsRedraw;

      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      redraw = redraw || this.viewManager.needsRedraw({
        clearRedrawFlags: clearRedrawFlags
      });
      redraw = redraw || this.layerManager.needsRedraw({
        clearRedrawFlags: clearRedrawFlags
      });
      return redraw;
    }
  }, {
    key: "getViews",
    value: function getViews() {
      return this.viewManager.views;
    } // Get a set of viewports for a given width and height

  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      return this.viewManager.getViewports(rect);
    }
  }, {
    key: "pickObject",
    value: function pickObject(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$radius = _ref3.radius,
          radius = _ref3$radius === void 0 ? 0 : _ref3$radius,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;
      this.stats.timeStart('deck.pickObject');
      var selectedInfos = this.layerManager.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        mode: 'query',
        depth: 1
      });
      this.stats.timeEnd('deck.pickObject');
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$radius = _ref4.radius,
          radius = _ref4$radius === void 0 ? 0 : _ref4$radius,
          _ref4$layerIds = _ref4.layerIds,
          layerIds = _ref4$layerIds === void 0 ? null : _ref4$layerIds,
          _ref4$depth = _ref4.depth,
          depth = _ref4$depth === void 0 ? 10 : _ref4$depth;
      this.stats.timeStart('deck.pickMultipleObjects');
      var selectedInfos = this.layerManager.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        mode: 'query',
        depth: depth
      });
      this.stats.timeEnd('deck.pickMultipleObjects');
      return selectedInfos;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref5) {
      var x = _ref5.x,
          y = _ref5.y,
          _ref5$width = _ref5.width,
          width = _ref5$width === void 0 ? 1 : _ref5$width,
          _ref5$height = _ref5.height,
          height = _ref5$height === void 0 ? 1 : _ref5$height,
          _ref5$layerIds = _ref5.layerIds,
          layerIds = _ref5$layerIds === void 0 ? null : _ref5$layerIds;
      this.stats.timeStart('deck.pickObjects');
      var infos = this.layerManager.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds,
        viewports: this.getViewports({
          x: x,
          y: y,
          width: width,
          height: height
        })
      });
      this.stats.timeEnd('deck.pickObjects');
      return infos;
    } // Private Methods
    // canvas, either string, canvas or `null`

  }, {
    key: "_createCanvas",
    value: function _createCanvas(props) {
      var canvas = props.canvas; // TODO EventManager should accept element id

      if (typeof canvas === 'string') {
        /* global document */
        canvas = document.getElementById(canvas);
        (0, _assert.default)(canvas);
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        var parent = props.parent || document.body;
        parent.appendChild(canvas);
      }

      var id = props.id,
          style = props.style;
      canvas.id = id;
      Object.assign(canvas.style, style);
      return canvas;
    } // Updates canvas width and/or height, if provided as props

  }, {
    key: "_setCanvasSize",
    value: function _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }

      var width = props.width,
          height = props.height; // Set size ONLY if props are being provided, otherwise let canvas be layouted freely

      if (width || width === 0) {
        width = Number.isFinite(width) ? "".concat(width, "px") : width;
        this.canvas.style.width = width;
      }

      if (height || height === 0) {
        height = Number.isFinite(height) ? "".concat(height, "px") : height; // Note: position==='absolute' required for height 100% to work

        this.canvas.style.position = 'absolute';
        this.canvas.style.height = height;
      }
    } // If canvas size has changed, updates

  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        var width = this.width,
            height = this.height;
        this.viewManager.setProps({
          width: width,
          height: height
        });
        this.props.onResize({
          width: this.width,
          height: this.height
        });
      }
    } // If canvas size has changed, reads out the new size and returns true

  }, {
    key: "_checkForCanvasSizeChange",
    value: function _checkForCanvasSizeChange() {
      var canvas = this.canvas;

      if (canvas && (this.width !== canvas.clientWidth || this.height !== canvas.clientHeight)) {
        this.width = canvas.clientWidth;
        this.height = canvas.clientHeight;
        return true;
      }

      return false;
    }
  }, {
    key: "_createAnimationLoop",
    value: function _createAnimationLoop(props) {
      var _this = this;

      var width = props.width,
          height = props.height,
          gl = props.gl,
          glOptions = props.glOptions,
          debug = props.debug,
          useDevicePixels = props.useDevicePixels,
          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      return new _luma.AnimationLoop({
        width: width,
        height: height,
        useDevicePixels: useDevicePixels,
        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
        onCreateContext: function onCreateContext(opts) {
          return gl || (0, _luma.createGLContext)(Object.assign({}, glOptions, opts, {
            canvas: _this.canvas,
            debug: debug
          }));
        },
        onInitialize: this._onRendererInitialized,
        onRender: this._onRenderFrame,
        onBeforeRender: props.onBeforeRender,
        onAfterRender: props.onAfterRender
      });
    } // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
    // TODO: For backwards compatibility ensure numeric width and height is added to the viewState

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      return props.viewState || this.viewState;
    } // Get the view descriptor list

  }, {
    key: "_getViews",
    value: function _getViews(props) {
      // Default to a full screen map view port
      var views = props.views || [new _mapView.default({
        id: 'default-view'
      })];
      views = Array.isArray(views) ? views : [views];

      if (views.length && props.controller) {
        // Backward compatibility: support controller prop
        views[0].props.controller = props.controller;
      }

      return views;
    }
  }, {
    key: "_pickAndCallback",
    value: function _pickAndCallback(options) {
      var pos = options.event.offsetCenter; // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a
      // assertion error when attempting to unproject the position.

      if (!pos) {
        return;
      }

      var radius = this.props.pickingRadius;
      var selectedInfos = this.layerManager.pickObject({
        x: pos.x,
        y: pos.y,
        radius: radius,
        viewports: this.getViewports(pos),
        mode: options.mode,
        depth: 1
      });

      if (options.callback && selectedInfos) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        }) || null; // As per documentation, send null value when no valid object is picked.

        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
      }
    }
  }, {
    key: "_updateCursor",
    value: function _updateCursor() {
      this.canvas.style.cursor = this.props.getCursor(this.interactiveState);
    } // Updates animation props on the layer context

  }, {
    key: "_updateAnimationProps",
    value: function _updateAnimationProps(animationProps) {
      this.layerManager.context.animationProps = animationProps;
    } // Deep integration (Mapbox styles)

  }, {
    key: "_setGLContext",
    value: function _setGLContext(gl) {
      if (this.layerManager) {
        return;
      } // if external context...


      if (this.props._customRender) {
        (0, _luma.trackContextState)(gl, {
          enable: true,
          copyState: true
        });
      }

      (0, _luma.setParameters)(gl, {
        blend: true,
        blendFunc: [_constants.default.SRC_ALPHA, _constants.default.ONE_MINUS_SRC_ALPHA, _constants.default.ONE, _constants.default.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: _constants.default.LEQUAL
      });
      this.props.onWebGLInitialized(gl);

      if (!this.props._customRender) {
        this.eventManager = new _mjolnir.EventManager(gl.canvas, {
          events: {
            click: this._onClick,
            pointermove: this._onPointerMove,
            pointerleave: this._onPointerLeave
          }
        });
      }

      this.viewManager = new _viewManager.default({
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange,
        onInteractiveStateChange: this._onInteractiveStateChange
      }); // Note: avoid React setState due GL animation loop / setState timing issue

      this.layerManager = new _layerManager.default(gl, {
        stats: this.stats
      });
      this.effectManager = new _effectManager.default({
        gl: gl,
        layerManager: this.layerManager
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setProps(this.props);

      this._updateCanvasSize();

      this.props.onLoad();
    }
  }, {
    key: "_drawLayers",
    value: function _drawLayers() {
      var animationProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var gl = this.layerManager.context.gl; // Log perf stats every second

      if (this.stats.oneSecondPassed()) {
        var table = this.stats.getStatsTable();
        this.stats.reset();

        _log.default.table(3, table)();
      }

      this._updateCanvasSize();

      this._updateCursor(); // Update layers if needed (e.g. some async prop has loaded)
      // Note: This can trigger a redraw


      this.layerManager.updateLayers();
      this.stats.bump('fps'); // Needs to be done before drawing

      this._updateAnimationProps(animationProps); // Check if we need to redraw


      var redrawReason = this.needsRedraw({
        clearRedrawFlags: true
      });

      if (!redrawReason) {
        return;
      } // Do the redraw


      this.stats.bump('render-fps');
      (0, _luma.setParameters)(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl: gl
      });
      this.layerManager.drawLayers({
        pass: 'screen',
        viewports: this.viewManager.getViewports(),
        views: this.viewManager.getViews(),
        redrawReason: redrawReason,
        drawPickingColors: this.props.drawPickingColors // Debug picking, helps in framebuffered layers

      });
      this.props.onAfterRender({
        gl: gl
      });
    } // Callbacks

  }, {
    key: "_onRendererInitialized",
    value: function _onRendererInitialized(_ref6) {
      var gl = _ref6.gl;

      this._setGLContext(gl);
    }
  }, {
    key: "_onRenderFrame",
    value: function _onRenderFrame(animationProps) {
      this._drawLayers(animationProps);
    } // Callbacks

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      // Let app know that view state is changing, and give it a chance to change it
      var viewState = this.props.onViewStateChange(params) || params.viewState; // If initialViewState was set on creation, auto track position

      if (this.viewState) {
        this.viewState[params.viewId] = viewState;
        this.viewManager.setProps({
          viewState: viewState
        });
      }
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref7) {
      var _ref7$isDragging = _ref7.isDragging,
          isDragging = _ref7$isDragging === void 0 ? false : _ref7$isDragging;

      if (isDragging !== this.interactiveState.isDragging) {
        this.interactiveState.isDragging = isDragging;
      }
    } // Route move events to layers. call the `onHover` prop of any picked layer,
    // and `onLayerHover` is called directly from here with any picking info generated by `pickLayer`.
    // @param {Object} event  A mjolnir.js event

  }, {
    key: "_onClick",
    value: function _onClick(event) {
      this._pickAndCallback({
        callback: this.props.onLayerClick,
        event: event,
        mode: 'click'
      });
    }
  }, {
    key: "_onPointerMove",
    value: function _onPointerMove(event) {
      if (event.leftButton || event.rightButton) {
        // Do not trigger onHover callbacks if mouse button is down.
        return;
      }

      this._pickAndCallback({
        callback: this.props.onLayerHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: "_onPointerLeave",
    value: function _onPointerLeave(event) {
      this.layerManager.pickObject({
        x: -1,
        y: -1,
        viewports: [],
        radius: 1,
        mode: 'hover'
      });

      if (this.props.onLayerHover) {
        this.props.onLayerHover(null, [], event.srcEvent);
      }
    }
  }]);

  return Deck;
}();

exports.default = Deck;
Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
//# sourceMappingURL=deck.js.map