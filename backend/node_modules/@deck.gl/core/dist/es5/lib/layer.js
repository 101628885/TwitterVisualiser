"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("./constants");

var _attributeManager = _interopRequireDefault(require("./attribute-manager"));

var _seerIntegration = require("./seer-integration");

var _props = require("../lifecycle/props");

var _count = require("../utils/count");

var _log = _interopRequireDefault(require("../utils/log"));

var _constants2 = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _component = _interopRequireDefault(require("../lifecycle/component"));

var _layerState = _interopRequireDefault(require("./layer-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var LOG_PRIORITY_UPDATE = 1;
var EMPTY_ARRAY = Object.freeze([]);

var noop = function noop() {};

var defaultProps = {
  // data: Special handling for null, see below
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: null,
  dataTransform: function dataTransform(data) {
    return data;
  },
  fetch: function (_fetch) {
    function fetch(_x) {
      return _fetch.apply(this, arguments);
    }

    fetch.toString = function () {
      return _fetch.toString();
    };

    return fetch;
  }(function (url) {
    return fetch(url).then(function (response) {
      return response.json();
    });
  }),
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0.8
  },
  onHover: noop,
  onClick: noop,
  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: [0, 0, 0],
  wrapLongitude: false,
  parameters: {},
  uniforms: {},
  framebuffer: null,
  animation: null,
  // Passed prop animation functions to evaluate props
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: [0, 0, 128, 128]
};

var Layer =
/*#__PURE__*/
function (_Component) {
  _inherits(Layer, _Component);

  function Layer() {
    _classCallCheck(this, Layer);

    return _possibleConstructorReturn(this, _getPrototypeOf(Layer).apply(this, arguments));
  }

  _createClass(Layer, [{
    key: "toString",
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return "".concat(className, "({id: '").concat(this.props.id, "'})");
    } // Public API
    // Updates selected state members and marks the object for redraw

  }, {
    key: "setState",
    value: function setState(updateObject) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, updateObject);
      this.setNeedsRedraw();
    } // Sets the redraw flag for this layer, will trigger a redraw next animation frame

  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.internalState) {
        this.internalState.needsRedraw = redraw;
      }
    } // This layer needs a deep update
    // TODO - Need to align with existing needsUpdate before uncommenting
    // For now async props will call layerManager directly

  }, {
    key: "setLayerNeedsUpdate",
    value: function setLayerNeedsUpdate() {
      this.context.layerManager.setNeedsUpdate(String(this));
    } // Checks state of attributes and model

  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? false : _ref2$clearRedrawFlag;

      return this._getNeedsRedraw(clearRedrawFlags);
    } // Checks if layer attributes needs updating

  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      // Call subclass lifecycle method
      return this.shouldUpdateState(this._getUpdateParams()); // End lifecycle method
    } // Returns true if the layer is pickable and visible.

  }, {
    key: "isPickable",
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    } // Return an array of models used by this layer, can be overriden by layer subclass

  }, {
    key: "getModels",
    value: function getModels() {
      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
    } // TODO - Gradually phase out, does not support multi model layers

  }, {
    key: "getSingleModel",
    value: function getSingleModel() {
      return this.state && this.state.model;
    }
  }, {
    key: "getAttributeManager",
    value: function getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    } // Returns the most recent layer that matched to this state
    // (When reacting to an async event, this layer may no longer be the latest)

  }, {
    key: "getCurrentLayer",
    value: function getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    } // Use iteration (the only required capability on data) to get first element
    // deprecated since we are effectively only supporting Arrays

  }, {
    key: "getFirstObject",
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    } // PROJECTION METHODS
    // Projects a point with current map state (lat, lon, zoom, pitch, bearing)
    // TODO - need to be extended to work with COORDINATE_SYSTEM.METERS,IDENTITY
    // TODO - need to be extended to work with multiple `views`

  }, {
    key: "project",
    value: function project(lngLat) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(lngLat));
      return viewport.project(lngLat);
    }
  }, {
    key: "unproject",
    value: function unproject(xy) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unproject(xy);
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(lngLat));
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: "use64bitProjection",
    value: function use64bitProjection() {
      if (this.props.fp64) {
        if (this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT) {
          return true;
        }

        _log.default.once(0, "64-bit mode only works with coordinateSystem set to\n        COORDINATE_SYSTEM.LNGLAT. Rendering in 32-bit mode instead");
      }

      return false;
    }
  }, {
    key: "use64bitPositions",
    value: function use64bitPositions() {
      return this.props.fp64 || this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL;
    } // TODO - needs to refer to context for devicePixels setting

  }, {
    key: "screenToDevicePixels",
    value: function screenToDevicePixels(screenPixels) {
      _log.default.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion')();

      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    } // Returns the picking color that doesn't match any subfeature
    // Use if some graphics do not belong to any pickable subfeature
    // @return {Array} - a black color

  }, {
    key: "nullPickingColor",
    value: function nullPickingColor() {
      return [0, 0, 0];
    } // Returns the picking color that doesn't match any subfeature
    // Use if some graphics do not belong to any pickable subfeature

  }, {
    key: "encodePickingColor",
    value: function encodePickingColor(i) {
      (0, _assert.default)((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    } // Returns the index corresponding to a picking color that doesn't match any subfeature
    // @param {Uint8Array} color - color array to be decoded
    // @return {Array} - the decoded picking color

  }, {
    key: "decodePickingColor",
    value: function decodePickingColor(color) {
      (0, _assert.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2]; // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    } // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses
    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: "initializeState",
    value: function initializeState() {
      throw new Error("Layer ".concat(this, " has not defined initializeState"));
    } // Let's layer control if updateState should be called

  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;
      return changeFlags.propsOrDataChanged;
    } // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: "updateState",
    value: function updateState(_ref4) {
      var oldProps = _ref4.oldProps,
          props = _ref4.props,
          context = _ref4.context,
          changeFlags = _ref4.changeFlags;
      var attributeManager = this.getAttributeManager();

      if (changeFlags.dataChanged && attributeManager) {
        attributeManager.invalidateAll();
      }
    } // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: "finalizeState",
    value: function finalizeState() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.getModels()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var model = _step2.value;
          model.delete();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.finalize();
      }
    } // If state has a model, draw it with supplied uniforms

  }, {
    key: "draw",
    value: function draw(opts) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var model = _step3.value;
          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    } // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;

      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    } // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////
    // INTERNAL METHODS
    // Default implementation of attribute invalidation, can be redefined

  }, {
    key: "invalidateAttribute",
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating all attributes: ".concat(diffReason))();

        attributeManager.invalidateAll();
      } else {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating attribute ".concat(name, ": ").concat(diffReason))();

        attributeManager.invalidate(name);
      }
    } // Calls attribute manager to update any WebGL attributes

  }, {
    key: "updateAttributes",
    value: function updateAttributes(props) {
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      } // Figure out data length


      var numInstances = this.getNumInstances(props);
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        transitions: props.transitions,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      var model = this.getSingleModel();

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({
          clearChangedFlags: true
        });
        model.setAttributes(changedAttributes);
      }
    } // Update attribute transition

  }, {
    key: "updateTransition",
    value: function updateTransition() {
      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
  }, {
    key: "calculateInstancePickingColors",
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size; // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    } // Sets the specified instanced picking color to null picking color. Used for multi picking.

  }, {
    key: "_clearInstancePickingColor",
    value: function _clearInstancePickingColor(color) {
      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;
      var value = instancePickingColors.value,
          size = instancePickingColors.size;
      var i = this.decodePickingColor(color);
      value[i * size + 0] = 0;
      value[i * size + 1] = 0;
      value[i * size + 2] = 0; // TODO: Optimize this to use sub-buffer update!

      instancePickingColors.update({
        value: value
      });
    } // Sets all occurrences of the specified picking color to null picking color. Used for multi picking.

  }, {
    key: "_clearPickingColor",
    value: function _clearPickingColor(color) {
      var pickingColors = this.getAttributeManager().attributes.pickingColors;
      var value = pickingColors.value;

      for (var i = 0; i < value.length; i += 3) {
        if (value[i + 0] === color[0] && value[i + 1] === color[1] && value[i + 2] === color[2]) {
          value[i + 0] = 0;
          value[i + 1] = 0;
          value[i + 2] = 0;
        }
      } // TODO: Optimize this to use sub-buffer update!


      pickingColors.update({
        value: value
      });
    } // This method figures out if we use instance colors or not
    // and calls _clearInstancePickingColor or _clearPickingColor

  }, {
    key: "clearPickingColor",
    value: function clearPickingColor(color) {
      if (this.getAttributeManager().attributes.pickingColors) {
        this._clearPickingColor(color);
      } else {
        this._clearInstancePickingColor(color);
      }
    }
  }, {
    key: "copyPickingColors",
    value: function copyPickingColors() {
      var _this$getAttributeMan = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan.pickingColors,
          instancePickingColors = _this$getAttributeMan.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      return new Uint8ClampedArray(colors.value);
    }
  }, {
    key: "restorePickingColors",
    value: function restorePickingColors(value) {
      var _this$getAttributeMan2 = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan2.pickingColors,
          instancePickingColors = _this$getAttributeMan2.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      colors.update({
        value: value
      });
    } // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: "getNumInstances",
    value: function getNumInstances(props) {
      props = props || this.props; // First check if the layer has set its own value

      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      } // Check if app has provided an explicit value


      if (props.numInstances !== undefined) {
        return props.numInstances;
      } // Use container library to get a count for any ES6 container or object


      var data = this.props.data;
      return (0, _count.count)(data);
    } // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class
    // Called by layer manager when a new layer is found

    /* eslint-disable max-statements */

  }, {
    key: "_initialize",
    value: function _initialize() {
      (0, _assert.default)(this.context.gl);

      this._initState(); // Call subclass lifecycle methods


      this.initializeState(this.context); // End subclass lifecycle methods
      // TODO deprecated, for backwards compatibility with older layers
      // in case layer resets state

      this.state.attributeManager = this.getAttributeManager(); // initializeState callback tends to clear state

      this.setChangeFlags({
        dataChanged: true,
        propsChanged: true,
        viewportChanged: true
      });

      this._updateState();

      var model = this.getSingleModel();

      if (model) {
        model.id = this.props.id;
        model.program.id = "".concat(this.props.id, "-program");
        model.geometry.id = "".concat(this.props.id, "-geometry");
      }
    } // Called by layer manager
    // if this layer is new (not matched with an existing layer) oldProps will be empty object

  }, {
    key: "_update",
    value: function _update() {
      // Call subclass lifecycle method
      var stateNeedsUpdate = this.needsUpdate(); // End lifecycle method

      if (stateNeedsUpdate) {
        this._updateState();
      }
    }
    /* eslint-enable max-statements */
    // Common code for _initialize and _update

  }, {
    key: "_updateState",
    value: function _updateState() {
      var updateParams = this._getUpdateParams(); // Call subclass lifecycle methods


      this.updateState(updateParams); // Render or update previously rendered sublayers

      if (this.isComposite) {
        this._renderLayers(updateParams);
      } // End subclass lifecycle methods
      // Add any subclass attributes


      this.updateAttributes(this.props);

      this._updateBaseUniforms(); // Note: Automatic instance count update only works for single layers


      if (this.state.model) {
        this.state.model.setInstanceCount(this.getNumInstances());
      }

      this.clearChangeFlags();
      this.internalState.resetOldProps();
    } // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: "_finalize",
    value: function _finalize() {
      (0, _assert.default)(this.internalState && this.state); // Call subclass lifecycle method

      this.finalizeState(this.context); // End lifecycle method

      (0, _seerIntegration.removeLayerInSeer)(this.id);
    } // Calculates uniforms

  }, {
    key: "drawLayer",
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === void 0 ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === void 0 ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === void 0 ? {} : _ref7$parameters;

      if (!uniforms.picking_uActive) {
        this.updateTransition();
      } // TODO/ib - hack move to luma Model.draw


      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      } // Hack/ib - define a public luma function


      var animationProps = this.context.animationProps;

      if (animationProps) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var model = _step4.value;

            model._setAnimationProps(animationProps);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } // Apply polygon offset to avoid z-fighting
      // TODO - move to draw-layers


      var getPolygonOffset = this.props.getPolygonOffset;
      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets; // Call subclass lifecycle method

      (0, _luma.withParameters)(this.context.gl, parameters, function () {
        _this.draw({
          moduleParameters: moduleParameters,
          uniforms: uniforms,
          parameters: parameters,
          context: _this.context
        });
      }); // End lifecycle method
    } // {uniforms = {}, ...opts}

  }, {
    key: "pickLayer",
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts); // End lifecycle method
    } // Helper methods

  }, {
    key: "getChangeFlags",
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    } // Dirty some change flags, will be handled by updateLayer

    /* eslint-disable complexity */

  }, {
    key: "setChangeFlags",
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags; // Update primary flags

      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "dataChanged: ".concat(flags.dataChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + "".concat(Object.keys(flags.updateTriggersChanged).join(', '), " in ").concat(_this2.id);
        })();
      }

      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "propsChanged: ".concat(flags.propsChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 2, function () {
          return "viewportChanged: ".concat(flags.viewportChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.stateChanged && !changeFlags.stateChanged) {
        changeFlags.stateChanged = flags.stateChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "stateChanged: ".concat(flags.stateChanged, " in ").concat(_this2.id);
        })();
      } // Update composite flags


      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
    }
    /* eslint-enable complexity */
    // Clear all changeFlags, typically after an update

  }, {
    key: "clearChangeFlags",
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        // Primary changeFlags, can be strings stating reason for change
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        // Derived changeFlags
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: "printChangeFlags",
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return "".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');
    } // Compares the layers props with old props from a matched older layer
    // and extracts change flags that describe what has change so that state
    // can be update correctly with minimal effort

  }, {
    key: "diffProps",
    value: function diffProps(newProps, oldProps) {
      var changeFlags = (0, _props.diffProps)(newProps, oldProps); // iterate over changedTriggers

      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }
  }, {
    key: "setModuleParameters",
    value: function setModuleParameters(moduleParameters) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;
          model.updateModuleSettings(moduleParameters);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    } // PRIVATE METHODS

  }, {
    key: "_getUpdateParams",
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    } // Checks state of attributes and model

  }, {
    key: "_getNeedsRedraw",
    value: function _getNeedsRedraw(clearRedrawFlags) {
      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.internalState) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      this.internalState.needsRedraw = this.internalState.needsRedraw && !clearRedrawFlags; // TODO - is attribute manager needed? - Model should be enough.

      var attributeManager = this.getAttributeManager();
      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({
        clearRedrawFlags: clearRedrawFlags
      });
      redraw = redraw || attributeManagerNeedsRedraw;
      redraw = redraw || this._modelNeedsRedraw(clearRedrawFlags);
      return redraw;
    }
  }, {
    key: "_modelNeedsRedraw",
    value: function _modelNeedsRedraw(clearRedrawFlags) {
      var redraw = false;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;
          var modelNeedsRedraw = model.getNeedsRedraw({
            clearRedrawFlags: clearRedrawFlags
          });

          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {
            modelNeedsRedraw = "model ".concat(model.id);
          }

          redraw = redraw || modelNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return redraw;
    } // Create new attribute manager

  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return new _attributeManager.default(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  }, {
    key: "_initState",
    value: function _initState() {
      (0, _assert.default)(!this.internalState && !this.state);

      var attributeManager = this._getAttributeManager();

      if (attributeManager) {
        // All instanced layers get instancePickingColors attribute by default
        // Their shaders can use it to render a picking scene
        // TODO - this slightly slows down non instanced layers
        attributeManager.addInstanced({
          instancePickingColors: {
            type: _constants2.default.UNSIGNED_BYTE,
            size: 3,
            update: this.calculateInstancePickingColors
          }
        });
      }

      this.internalState = new _layerState.default({
        attributeManager: attributeManager,
        layer: this
      });
      this.state = {}; // TODO deprecated, for backwards compatibility with older layers

      this.state.attributeManager = attributeManager;
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this); // Ensure any async props are updated

      this.internalState.setAsyncProps(this.props);
    } // Called by layer manager to transfer state from an old layer

  }, {
    key: "_transferState",
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState;
      (0, _assert.default)(state && internalState);

      if (this === oldLayer) {
        return;
      } // Move internalState


      this.internalState = internalState;
      this.internalState.component = this; // Move state

      this.state = state; // Deprecated: layer references on `state`

      state.layer = this; // We keep the state ref on old layers to support async actions
      // oldLayer.state = null;
      // Ensure any async props are updated

      this.internalState.setAsyncProps(this.props); // Update model layer reference

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;
          model.userData.layer = this;
        } // Ensure any async props are updated

      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      this.internalState.setAsyncProps(this.props);
      this.diffProps(this.props, this.internalState.getOldProps());
    }
  }, {
    key: "_onAsyncPropUpdated",
    value: function _onAsyncPropUpdated() {
      this.diffProps(this.props, this.internalState.getOldProps());
      this.setLayerNeedsUpdate();
    } // Operate on each changed triggers, will be called when an updateTrigger changes

  }, {
    key: "_activeUpdateTrigger",
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    } //  Helper to check that required props are supplied

  }, {
    key: "_checkRequiredProp",
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];

      if (value === undefined) {
        throw new Error("Property ".concat(propertyName, " undefined in layer ").concat(this));
      }

      if (condition && !condition(value)) {
        throw new Error("Bad property ".concat(propertyName, " in layer ").concat(this));
      }
    }
  }, {
    key: "_updateBaseUniforms",
    value: function _updateBaseUniforms() {
      var _this3 = this;

      var uniforms = {
        // apply gamma to opacity to make it visually "linear"
        opacity: typeof this.props.opacity === 'function' ? function (animationProps) {
          return Math.pow(_this3.props.opacity(animationProps), 1 / 2.2);
        } : Math.pow(this.props.opacity, 1 / 2.2)
      };
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var model = _step8.value;
          model.setUniforms(uniforms);
        } // TODO - set needsRedraw on the model(s)?

      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.setNeedsRedraw();
    } // DEPRECATED METHODS
    // Updates selected state members and marks the object for redraw

  }, {
    key: "setUniforms",
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this.getModels()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var model = _step9.value;
          model.setUniforms(uniformMap);
        } // TODO - set needsRedraw on the model(s)?

      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      this.setNeedsRedraw();

      _log.default.deprecated('layer.setUniforms', 'model.setUniforms')();
    }
  }, {
    key: "is64bitEnabled",
    value: function is64bitEnabled() {
      _log.default.deprecated('is64bitEnabled', 'use64bitProjection')();

      return this.use64bitProjection();
    }
  }]);

  return Layer;
}(_component.default);

exports.default = Layer;
Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;
//# sourceMappingURL=layer.js.map