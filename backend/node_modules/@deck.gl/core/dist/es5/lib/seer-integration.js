"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLayerInSeer = exports.updateLayerInSeer = exports.initLayerInSeer = exports.seerInitListener = exports.layerEditListener = exports.applyPropOverrides = exports.setPropOverrides = void 0;

var _seer = _interopRequireDefault(require("seer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * Recursively set a nested property of an object given a properties array and a value
 */
var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();
/**
 * Create an override on the specify layer, indexed by a valuePath array.
 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
 */

var setPropOverrides = function setPropOverrides(id, valuePath, value) {
  if (!_seer.default.isReady()) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var props = overrides.get(id);
  props.set(valuePath, value);
};
/**
 * Get the props overrides of a specific layer if Seer as been initialized
 * Invalidates the data to be sure new ones are always picked up.
 */


exports.setPropOverrides = setPropOverrides;

var applyPropOverrides = function applyPropOverrides(props) {
  if (!_seer.default.isReady() || !props.id) {
    return;
  }

  var overs = overrides.get(props.id);

  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(props, valuePath, value); // Invalidate data array if we have a data override

    if (valuePath[0] === 'data') {
      props.data = _toConsumableArray(props.data);
    }
  });
};
/**
 * Listen for deck.gl edit events
 */


exports.applyPropOverrides = applyPropOverrides;

var layerEditListener = function layerEditListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('deck.gl', cb);
};
/**
 * Listen for seer init events to resend data
 */


exports.layerEditListener = layerEditListener;

var seerInitListener = function seerInitListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('init', cb);
};

exports.seerInitListener = seerInitListener;

var initLayerInSeer = function initLayerInSeer(layer) {
  if (!_seer.default.isReady() || !layer) {
    return;
  }

  var badges = [layer.constructor.layerName];

  _seer.default.listItem('deck.gl', layer.id, {
    badges: badges,
    // TODO: Seer currently only handles single model layers
    links: layer.state && layer.state.model ? ["luma.gl:".concat(layer.state.model.id)] : undefined,
    parent: layer.parent ? layer.parent.id : undefined
  });
};
/**
 * Log layer's properties to Seer
 */


exports.initLayerInSeer = initLayerInSeer;

var updateLayerInSeer = function updateLayerInSeer(layer) {
  if (!_seer.default.isReady() || _seer.default.throttle("deck.gl:".concat(layer.id), 1e3)) {
    return;
  }

  var data = logPayload(layer);

  _seer.default.multiUpdate('deck.gl', layer.id, data);
};
/**
 * On finalize of a specify layer, remove it from seer
 */


exports.updateLayerInSeer = updateLayerInSeer;

var removeLayerInSeer = function removeLayerInSeer(id) {
  if (!_seer.default.isReady() || !id) {
    return;
  }

  _seer.default.deleteItem('deck.gl', id);
};

exports.removeLayerInSeer = removeLayerInSeer;

function logPayload(layer) {
  var data = [{
    path: 'objects.props',
    data: layer.props
  }];
  var badges = [layer.constructor.layerName];

  if (layer.state) {
    if (layer.getAttributeManager()) {
      var attrs = layer.getAttributeManager().getAttributes();
      data.push({
        path: 'objects.attributes',
        data: attrs
      });
      badges.push(layer.getAttributeManager().stats.getTimeString());
    } // TODO: Seer currently only handles single model layers


    if (layer.state.model) {
      layer.state.model.setProps({
        timerQueryEnabled: true
      });
      var lastFrameTime = layer.state.model.stats.lastFrameTime;

      if (lastFrameTime) {
        badges.push("".concat((lastFrameTime * 1000).toFixed(0), "\u03BCs"));
      }
    }
  }

  data.push({
    path: 'badges',
    data: badges
  });
  return data;
}
//# sourceMappingURL=seer-integration.js.map