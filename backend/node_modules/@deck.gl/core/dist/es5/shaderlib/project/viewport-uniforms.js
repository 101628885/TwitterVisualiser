"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUniformsFromViewport = getUniformsFromViewport;

var _multiply = _interopRequireDefault(require("gl-mat4/multiply"));

var _transformMat = _interopRequireDefault(require("gl-vec4/transformMat4"));

var _constants = require("../../lib/constants");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _log = _interopRequireDefault(require("../../utils/log"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

var _constants2 = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0]; // 4x4 matrix that drops 4th component of vector

var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0]; // Based on viewport-mercator-project/test/fp32-limits.js

var LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = 12;
var getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);

function getShaderCoordinateSystem(coordinateSystem, fp64) {
  if (fp64) {
    // This is the only mode that works with fp64
    return _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;
  }

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET;

    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
    default:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants.COORDINATE_SYSTEM.METERS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS;

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS;

    case _constants.COORDINATE_SYSTEM.IDENTITY:
      return _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY;
  }
} // The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging


function calculateMatrixAndOffset(_ref) {
  var viewport = _ref.viewport,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom,
      fp64 = _ref.fp64;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;
  var projectionCenter;
  var shaderCoordinateSystem = getShaderCoordinateSystem(coordinateSystem, fp64);
  var shaderCoordinateOrigin = coordinateOrigin;

  if (shaderCoordinateSystem === _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET) {
    if (coordinateZoom < LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {
      // Use LNG_LAT projection if not zooming
      shaderCoordinateSystem = _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;
    } else {
      // Use LNGLAT_AUTO_OFFSET
      var lng = Math.fround(viewport.longitude);
      var lat = Math.fround(viewport.latitude);
      shaderCoordinateOrigin = [lng, lat];
    }
  }

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT:
      projectionCenter = ZERO_VECTOR;
      break;
    // TODO: make lighting work for meter offset mode

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
      // Calculate transformed projectionCenter (using 64 bit precision JS)
      // This is the key to offset mode precision
      // (avoids doing this addition in 32 bit precision in GLSL)
      var positionPixels = viewport.projectFlat(shaderCoordinateOrigin, Math.pow(2, coordinateZoom)); // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

      projectionCenter = (0, _transformMat.default)([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix); // Always apply uncentered projection matrix if available (shader adds center)

      viewMatrix = viewMatrixUncentered || viewMatrix; // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);

      viewProjectionMatrix = (0, _multiply.default)([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = (0, _multiply.default)([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: viewport.cameraPosition,
    shaderCoordinateSystem: shaderCoordinateSystem,
    shaderCoordinateOrigin: shaderCoordinateOrigin
  };
}
/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */


function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$devicePixelRati = _ref2.devicePixelRatio,
      devicePixelRatio = _ref2$devicePixelRati === void 0 ? 1 : _ref2$devicePixelRati,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === void 0 ? null : _ref2$modelMatrix,
      _ref2$coordinateSyste = _ref2.coordinateSystem,
      coordinateSystem = _ref2$coordinateSyste === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
      coordinateOrigin = _ref2$coordinateOrigi === void 0 ? DEFAULT_COORDINATE_ORIGIN : _ref2$coordinateOrigi,
      _ref2$wrapLongitude = _ref2.wrapLongitude,
      wrapLongitude = _ref2$wrapLongitude === void 0 ? false : _ref2$wrapLongitude,
      _ref2$fp = _ref2.fp64,
      fp64 = _ref2$fp === void 0 ? false : _ref2$fp,
      projectionMode = _ref2.projectionMode,
      positionOrigin = _ref2.positionOrigin;

  (0, _assert.default)(viewport);

  if (projectionMode !== undefined) {
    _log.default.removed('projectionMode', 'coordinateSystem');
  }

  if (positionOrigin !== undefined) {
    _log.default.removed('positionOrigin', 'coordinateOrigin');
  }

  return Object.assign({
    project_uModelMatrix: modelMatrix || IDENTITY_MATRIX
  }, getMemoizedViewportUniforms({
    viewport: viewport,
    devicePixelRatio: devicePixelRatio,
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    wrapLongitude: wrapLongitude,
    fp64: fp64
  }));
}

function calculateViewportUniforms(_ref3) {
  var viewport = _ref3.viewport,
      devicePixelRatio = _ref3.devicePixelRatio,
      coordinateSystem = _ref3.coordinateSystem,
      coordinateOrigin = _ref3.coordinateOrigin,
      wrapLongitude = _ref3.wrapLongitude,
      fp64 = _ref3.fp64;
  var coordinateZoom = viewport.zoom;
  (0, _assert.default)(coordinateZoom >= 0);

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    coordinateZoom: coordinateZoom,
    viewport: viewport,
    fp64: fp64
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos,
      shaderCoordinateSystem = _calculateMatrixAndOf.shaderCoordinateSystem,
      shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin;

  (0, _assert.default)(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix'); // Calculate projection pixels per unit

  var distanceScales = viewport.getDistanceScales();
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  var uniforms = {
    // Projection mode values
    project_uCoordinateSystem: shaderCoordinateSystem,
    project_uCenter: projectionCenter,
    project_uWrapLongitude: wrapLongitude,
    project_uAntimeridian: (viewport.longitude || 0) - 180,
    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    // Distance at which screen pixels are projected
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,
    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,
    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    // This is the mercator scale (2 ** zoom)
    project_uViewProjectionMatrix: viewProjectionMatrix,
    // This is for lighting calculations
    project_uCameraPosition: cameraPos
  };
  var distanceScalesAtOrigin = viewport.getDistanceScales(shaderCoordinateOrigin);

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
      uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;
      uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
      uniforms.project_coordinate_origin = shaderCoordinateOrigin;
    // eslint-disable-line no-fallthrough

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerDegree;
      uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerDegree2;
      break;

    default:
      break;
  }

  return uniforms;
}
//# sourceMappingURL=viewport-uniforms.js.map