"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _log = _interopRequireDefault(require("../utils/log"));

var _mathUtils = require("../utils/math-utils");

var _math = require("math.gl");

var _scale = _interopRequireDefault(require("gl-mat4/scale"));

var _translate = _interopRequireDefault(require("gl-mat4/translate"));

var _multiply = _interopRequireDefault(require("gl-mat4/multiply"));

var _invert = _interopRequireDefault(require("gl-mat4/invert"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEGREES_TO_RADIANS = Math.PI / 180;
var IDENTITY = (0, _mathUtils.createMat4)();
var ZERO_VECTOR = [0, 0, 0];
var DEFAULT_DISTANCE_SCALES = {
  pixelsPerMeter: [1, 1, 1],
  metersPerPixel: [1, 1, 1],
  pixelsPerDegree: [1, 1, 1],
  degreesPerPixel: [1, 1, 1]
};
var DEFAULT_ZOOM = 0;
var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport =
/*#__PURE__*/
function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Viewport);

    var _opts$id = opts.id,
        id = _opts$id === void 0 ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === void 0 ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === void 0 ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === void 0 ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === void 0 ? 1 : _opts$height;
    this.id = id || this.constructor.displayName || 'viewport';
    this.x = x;
    this.y = y; // Silently allow apps to send in w,h = 0,0

    this.width = width || 1;
    this.height = height || 1;

    this._initViewMatrix(opts);

    this._initProjectionMatrix(opts);

    this._initPixelMatrices(); // Bind methods for easy access


    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  } // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: "equals",
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix); // TODO - check distance scales?
    }
    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: "project",
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === void 0 ? 0 : _xyz$;

      var _this$projectFlat = this.projectFlat([x0, y0]),
          _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),
          X = _this$projectFlat2[0],
          Y = _this$projectFlat2[1];

      var coord = (0, _viewportMercatorProject.worldToPixels)([X, Y, z0], this.pixelProjectionMatrix);

      var _coord = _slicedToArray(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether origin is top left
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft,
          targetZ = _ref2.targetZ;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          z = _xyz2[2];

      var y2 = topLeft ? y : this.height - y;
      var coord = (0, _viewportMercatorProject.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZ);

      var _this$unprojectFlat = this.unprojectFlat(coord),
          _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),
          X = _this$unprojectFlat2[0],
          Y = _this$unprojectFlat2[1];

      if (Number.isFinite(z)) {
        // Has depth component
        return [X, Y, coord[2]];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    } // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.lngLatToWorld)(xyz, scale);
      }

      return xyz;
    }
    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.worldToLngLat)(xyz, scale);
      }

      return xyz;
    }
  }, {
    key: "getDistanceScales",
    value: function getDistanceScales() {
      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (coordinateOrigin) {
        return (0, _viewportMercatorProject.getDistanceScales)({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          scale: this.scale,
          highPrecision: true
        });
      }

      return this.distanceScales;
    }
  }, {
    key: "getMatrices",
    value: function getMatrices() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$modelMatrix = _ref3.modelMatrix,
          modelMatrix = _ref3$modelMatrix === void 0 ? null : _ref3$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = (0, _multiply.default)([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = (0, _multiply.default)([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = (0, _invert.default)([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,
        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,
        width: this.width,
        height: this.height,
        scale: this.scale
      });
      return matrices;
    }
  }, {
    key: "containsPixel",
    value: function containsPixel(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height;
      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
    } // EXPERIMENTAL METHODS

  }, {
    key: "getCameraPosition",
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: "getCameraDirection",
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: "getCameraUp",
    value: function getCameraUp() {
      return this.cameraUp;
    } // INTERNAL METHODS
    // TODO - these are duplicating WebMercator methods

  }, {
    key: "_addMetersToLngLat",
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

      var _this$_metersToLngLat = this._metersToLngLatDelta(xyz),
          _this$_metersToLngLat2 = _slicedToArray(_this$_metersToLngLat, 3),
          deltaLng = _this$_metersToLngLat2[0],
          deltaLat = _this$_metersToLngLat2[1],
          _this$_metersToLngLat3 = _this$_metersToLngLat2[2],
          deltaZ = _this$_metersToLngLat3 === void 0 ? 0 : _this$_metersToLngLat3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: "_metersToLngLatDelta",
    value: function _metersToLngLatDelta(xyz) {
      var _xyz3 = _slicedToArray(xyz, 3),
          x = _xyz3[0],
          y = _xyz3[1],
          _xyz3$ = _xyz3[2],
          z = _xyz3$ === void 0 ? 0 : _xyz3$;

      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _this$distanceScales = this.distanceScales,
          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
          degreesPerPixel = _this$distanceScales.degreesPerPixel;
      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }
  }, {
    key: "_createProjectionMatrix",
    value: function _createProjectionMatrix(_ref5) {
      var orthographic = _ref5.orthographic,
          fovyRadians = _ref5.fovyRadians,
          aspect = _ref5.aspect,
          focalDistance = _ref5.focalDistance,
          near = _ref5.near,
          far = _ref5.far;
      (0, _assert.default)(Number.isFinite(fovyRadians));
      return orthographic ? new _math.Matrix4().orthographic({
        fovy: fovyRadians,
        aspect: aspect,
        focalDistance: focalDistance,
        near: near,
        far: far
      }) : new _math.Matrix4().perspective({
        fovy: fovyRadians,
        aspect: aspect,
        near: near,
        far: far
      });
    }
    /* eslint-disable complexity, max-statements */

  }, {
    key: "_initViewMatrix",
    value: function _initViewMatrix(opts) {
      var _opts$viewMatrix = opts.viewMatrix,
          viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,
          _opts$longitude = opts.longitude,
          longitude = _opts$longitude === void 0 ? null : _opts$longitude,
          _opts$latitude = opts.latitude,
          latitude = _opts$latitude === void 0 ? null : _opts$latitude,
          _opts$zoom = opts.zoom,
          zoom = _opts$zoom === void 0 ? null : _opts$zoom,
          _opts$position = opts.position,
          position = _opts$position === void 0 ? null : _opts$position,
          _opts$modelMatrix = opts.modelMatrix,
          modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,
          _opts$focalDistance = opts.focalDistance,
          focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,
          _opts$distanceScales = opts.distanceScales,
          distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales; // Check if we have a geospatial anchor

      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this.zoom = zoom;

      if (!Number.isFinite(this.zoom)) {
        this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMeterZoom)({
          latitude: latitude
        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
      }

      this.scale = Math.pow(2, this.zoom); // Calculate distance scales if lng/lat/zoom are provided

      this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getDistanceScales)({
        latitude: latitude,
        longitude: longitude,
        scale: this.scale
      }) : distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = focalDistance;
      this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
      this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);
      this.position = ZERO_VECTOR;
      this.meterOffset = ZERO_VECTOR;

      if (position) {
        // Apply model matrix if supplied
        this.position = position;
        this.modelMatrix = modelMatrix;
        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
      }

      this.viewMatrixUncentered = viewMatrix;

      if (this.isGeospatial) {
        // Determine camera center
        this.center = this._getCenterInWorld({
          longitude: longitude,
          latitude: latitude
        }); // Make a centered version of the matrix for projection modes without an offset

        this.viewMatrix = new _math.Matrix4() // Apply the uncentered view matrix
        .multiplyRight(this.viewMatrixUncentered) // The Mercator world coordinate system is upper left,
        // but GL expects lower left, so we flip it around the center after all transforms are done
        .scale([1, -1, 1]) // And center it
        .translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());
      } else {
        this.center = position;
        this.viewMatrix = viewMatrix;
      }
    }
    /* eslint-enable complexity, max-statements */

  }, {
    key: "_getCenterInWorld",
    value: function _getCenterInWorld(_ref6) {
      var longitude = _ref6.longitude,
          latitude = _ref6.latitude;
      var meterOffset = this.meterOffset,
          scale = this.scale,
          distanceScales = this.distanceScales; // Make a centered version of the matrix for projection modes without an offset

      var center2d = this.projectFlat([longitude, latitude], scale);
      var center = new _math.Vector3(center2d[0], center2d[1], 0);

      if (meterOffset) {
        var pixelPosition = new _math.Vector3(meterOffset) // Convert to pixels in current zoom
        .scale(distanceScales.pixelsPerMeter) // We want positive Y to represent an offset towards north,
        // but web mercator world coordinates is top-left
        .scale([1, -1, 1]);
        center.add(pixelPosition);
      }

      return center;
    }
  }, {
    key: "_initProjectionMatrix",
    value: function _initProjectionMatrix(opts) {
      var _opts$projectionMatri = opts.projectionMatrix,
          projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,
          _opts$orthographic = opts.orthographic,
          orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,
          fovyRadians = opts.fovyRadians,
          fovyDegrees = opts.fovyDegrees,
          fovy = opts.fovy,
          _opts$near = opts.near,
          near = _opts$near === void 0 ? 0.1 : _opts$near,
          _opts$far = opts.far,
          far = _opts$far === void 0 ? 1000 : _opts$far,
          _opts$focalDistance2 = opts.focalDistance,
          focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2,
          orthographicFocalDistance = opts.orthographicFocalDistance;
      var radians = fovyRadians || (fovyDegrees || fovy || 75) * DEGREES_TO_RADIANS;
      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({
        orthographic: orthographic,
        fovyRadians: radians,
        aspect: this.width / this.height,
        focalDistance: orthographicFocalDistance || focalDistance,
        near: near,
        far: far
      });
    }
  }, {
    key: "_initPixelMatrices",
    value: function _initPixelMatrices() {
      // Note: As usual, matrix operations should be applied in "reverse" order
      // since vectors will be multiplied in from the right during transformation
      var vpm = (0, _mathUtils.createMat4)();
      (0, _multiply.default)(vpm, vpm, this.projectionMatrix);
      (0, _multiply.default)(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm; // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);
      // Calculate inverse view matrix

      this.viewMatrixInverse = (0, _invert.default)([], this.viewMatrix) || this.viewMatrix; // Decompose camera directions

      var _extractCameraVectors = (0, _mathUtils.extractCameraVectors)({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up; // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);

      /*
       * Builds matrices that converts preprojected lngLats to screen pixels
       * and vice versa.
       * Note: Currently returns bottom-left coordinates!
       * Note: Starts with the GL projection matrix and adds steps to the
       *       scale and translate that matrix onto the window.
       * Note: WebGL controls clip space to screen projection with gl.viewport
       *       and does not need this step.
       */
      // matrix for conversion from world location to screen (pixel) coordinates

      var m = (0, _mathUtils.createMat4)();
      (0, _scale.default)(m, m, [this.width / 2, -this.height / 2, 1]);
      (0, _translate.default)(m, m, [1, -1, 0]);
      (0, _multiply.default)(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;
      this.pixelUnprojectionMatrix = (0, _invert.default)((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);

      if (!this.pixelUnprojectionMatrix) {
        _log.default.warn('Pixel project matrix not invertible')(); // throw new Error('Pixel project matrix not invertible');

      }
    }
  }]);

  return Viewport;
}();

exports.default = Viewport;
Viewport.displayName = 'Viewport';
//# sourceMappingURL=viewport.js.map