function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import GL from 'luma.gl/constants';
import { Buffer, Model, Framebuffer, Texture2D, FEATURES, hasFeatures, isWebGL2 } from 'luma.gl';
import { log } from '@deck.gl/core';
import assert from 'assert';
import { fp64 as fp64Utils } from 'luma.gl';
import { worldToPixels } from 'viewport-mercator-project';
var fp64ifyMatrix4 = fp64Utils.fp64ifyMatrix4;
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var PIXEL_SIZE = 4; // RGBA32F

import AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';
import AGGREGATE_TO_GRID_VS_FP64 from './aggregate-to-grid-vs-64.glsl';
import AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';
import AGGREGATE_ALL_VS_FP64 from './aggregate-all-vs-64.glsl';
import AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';
var DEFAULT_CHANGE_FLAGS = {
  dataChanged: true,
  viewportChanged: true,
  cellSizeChanged: true
};

var GPUGridAggregator =
/*#__PURE__*/
function () {
  _createClass(GPUGridAggregator, null, [{
    key: "getAggregationData",
    // Decode and return aggregation data of given pixel.
    value: function getAggregationData(_ref) {
      var countsData = _ref.countsData,
          maxCountData = _ref.maxCountData,
          pixelIndex = _ref.pixelIndex;
      assert(countsData.length >= (pixelIndex + 1) * PIXEL_SIZE);
      assert(maxCountData.length === PIXEL_SIZE);
      var index = pixelIndex * PIXEL_SIZE;
      var cellCount = countsData[index];
      var cellWeight = countsData[index + 1];
      var totalCount = maxCountData[0];
      var totalWeight = maxCountData[1];
      var maxCellWieght = maxCountData[3];
      return {
        cellCount: cellCount,
        cellWeight: cellWeight,
        totalCount: totalCount,
        totalWeight: totalWeight,
        maxCellWieght: maxCellWieght
      };
    } // Decodes and retuns counts and weights of all cells

  }, {
    key: "getCellData",
    value: function getCellData(_ref2) {
      var countsData = _ref2.countsData;
      var cellWeights = [];
      var cellCounts = [];

      for (var index = 0; index < countsData.length; index += 4) {
        cellCounts.push(countsData[index]);
        cellWeights.push(countsData[index + 1]);
      }

      return {
        cellCounts: cellCounts,
        cellWeights: cellWeights
      };
    } // DEBUG ONLY
    // static logData({countsBuffer, maxCountBuffer}) {
    //   const countsData = countsBuffer.getData();
    //   for (let index = 0; index < countsData.length; index += 4) {
    //     if (countsData[index] > 0) {
    //       console.log(`index: ${index} count: ${countsData[index]}`);
    //     }
    //   }
    //   const maxCountData = maxCountBuffer.getData();
    //   console.log(`totalCount: ${maxCountData[0]} totalWeight: ${maxCountData[1]} maxCellWieght: ${maxCountData[3]}`);
    // }

  }]);

  function GPUGridAggregator(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, GPUGridAggregator);

    this.id = opts.id || 'gpu-grid-aggregator';
    this.shaderCache = opts.shaderCache || null;
    this.gl = gl;
    this.state = {};
    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT);

    if (this._hasGPUSupport) {
      this._setupGPUResources();
    }
  } // Perform aggregation and retun the results


  _createClass(GPUGridAggregator, [{
    key: "run",
    value: function run() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          positions = _ref3.positions,
          positions64xyLow = _ref3.positions64xyLow,
          weights = _ref3.weights,
          _ref3$changeFlags = _ref3.changeFlags,
          changeFlags = _ref3$changeFlags === void 0 ? DEFAULT_CHANGE_FLAGS : _ref3$changeFlags,
          cellSize = _ref3.cellSize,
          viewport = _ref3.viewport,
          width = _ref3.width,
          height = _ref3.height,
          _ref3$countsBuffer = _ref3.countsBuffer,
          countsBuffer = _ref3$countsBuffer === void 0 ? null : _ref3$countsBuffer,
          _ref3$maxCountBuffer = _ref3.maxCountBuffer,
          maxCountBuffer = _ref3$maxCountBuffer === void 0 ? null : _ref3$maxCountBuffer,
          _ref3$gridTransformMa = _ref3.gridTransformMatrix,
          gridTransformMatrix = _ref3$gridTransformMa === void 0 ? null : _ref3$gridTransformMa,
          _ref3$projectPoints = _ref3.projectPoints,
          projectPoints = _ref3$projectPoints === void 0 ? false : _ref3$projectPoints,
          _ref3$useGPU = _ref3.useGPU,
          useGPU = _ref3$useGPU === void 0 ? true : _ref3$useGPU,
          _ref3$fp = _ref3.fp64,
          fp64 = _ref3$fp === void 0 ? false : _ref3$fp;

      if (this.state.useGPU !== useGPU) {
        changeFlags = DEFAULT_CHANGE_FLAGS;
      }

      this._setState({
        useGPU: useGPU
      });

      var transformMatrix = gridTransformMatrix || viewport && viewport.pixelProjectionMatrix || IDENTITY_MATRIX;
      var aggregationParams = {
        positions: positions,
        positions64xyLow: positions64xyLow,
        weights: weights,
        changeFlags: changeFlags,
        cellSize: cellSize,
        viewport: viewport,
        gridTransformMatrix: transformMatrix,
        countsBuffer: countsBuffer,
        maxCountBuffer: maxCountBuffer,
        projectPoints: projectPoints,
        fp64: fp64
      };

      this._updateGridSize({
        viewport: viewport,
        cellSize: cellSize,
        width: width,
        height: height
      });

      if (this._hasGPUSupport && useGPU) {
        return this._runAggregationOnGPU(aggregationParams);
      }

      if (useGPU) {
        log.warn('ScreenGridAggregator: GPU Aggregation not supported, falling back to CPU');
      }

      return this._runAggregationOnCPU(aggregationParams);
    } // PRIVATE

  }, {
    key: "_getAggregateData",
    value: function _getAggregateData(opts) {
      var countsBuffer = opts.countsBuffer,
          maxCountBuffer = opts.maxCountBuffer;
      countsBuffer = this.gridAggregationFramebuffer.readPixelsToBuffer({
        buffer: countsBuffer,
        type: GL.FLOAT
      });
      maxCountBuffer = this.allAggregrationFramebuffer.readPixelsToBuffer({
        width: 1,
        height: 1,
        type: GL.FLOAT,
        buffer: maxCountBuffer
      });
      return {
        countsBuffer: countsBuffer,
        countsTexture: this.gridAggregationFramebuffer.texture,
        maxCountBuffer: maxCountBuffer,
        maxCountTexture: this.allAggregrationFramebuffer.texture
      };
    }
  }, {
    key: "_getAggregationModel",
    value: function _getAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new Model(gl, {
        id: 'Gird-Aggregation-Model',
        vs: fp64 ? AGGREGATE_TO_GRID_VS_FP64 : AGGREGATE_TO_GRID_VS,
        fs: AGGREGATE_TO_GRID_FS,
        modules: fp64 ? ['fp64', 'project64'] : ['project32'],
        shaderCache: shaderCache,
        vertexCount: 0,
        drawMode: GL.POINTS
      });
    }
  }, {
    key: "_getAllAggregationModel",
    value: function _getAllAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new Model(gl, {
        id: 'All-Aggregation-Model',
        vs: AGGREGATE_ALL_VS_FP64,
        fs: AGGREGATE_ALL_FS,
        modules: ['fp64'],
        shaderCache: shaderCache,
        vertexCount: 1,
        drawMode: GL.POINTS,
        isInstanced: true,
        instanceCount: 0,
        attributes: {
          position: new Buffer(gl, {
            size: 2,
            data: new Float32Array([0, 0])
          })
        }
      });
    }
  }, {
    key: "_projectPositions",
    value: function _projectPositions(opts) {
      var projectedPositions = this.state.projectedPositions;

      if (!projectedPositions || opts.changeFlags.dataChanged || opts.changeFlags.viewportChanged) {
        var positions = opts.positions,
            viewport = opts.viewport;
        projectedPositions = [];

        for (var index = 0; index < positions.length; index += 2) {
          var _viewport$projectFlat = viewport.projectFlat([positions[index], positions[index + 1]]),
              _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),
              x = _viewport$projectFlat2[0],
              y = _viewport$projectFlat2[1];

          projectedPositions.push(x, y);
        }

        this._setState({
          projectedPositions: projectedPositions
        });
      }
    }
  }, {
    key: "_renderAggregateData",
    value: function _renderAggregateData(opts) {
      var cellSize = opts.cellSize,
          viewport = opts.viewport,
          gridTransformMatrix = opts.gridTransformMatrix,
          projectPoints = opts.projectPoints;
      var _this$state = this.state,
          numCol = _this$state.numCol,
          numRow = _this$state.numRow,
          windowSize = _this$state.windowSize;
      var gl = this.gl,
          gridAggregationFramebuffer = this.gridAggregationFramebuffer,
          gridAggregationModel = this.gridAggregationModel,
          allAggregrationFramebuffer = this.allAggregrationFramebuffer,
          allAggregationModel = this.allAggregationModel;
      var uProjectionMatrixFP64 = fp64ifyMatrix4(gridTransformMatrix);
      var gridSize = [numCol, numRow];
      gridAggregationFramebuffer.bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gridAggregationModel.draw({
        parameters: {
          clearColor: [0, 0, 0, 0],
          clearDepth: 0,
          blend: true,
          depthTest: false,
          blendEquation: GL.FUNC_ADD,
          blendFunc: [GL.ONE, GL.ONE]
        },
        moduleSettings: {
          viewport: viewport
        },
        uniforms: {
          windowSize: windowSize,
          cellSize: cellSize,
          gridSize: gridSize,
          uProjectionMatrix: gridTransformMatrix,
          uProjectionMatrixFP64: uProjectionMatrixFP64,
          projectPoints: projectPoints
        }
      });
      gridAggregationFramebuffer.unbind();
      allAggregrationFramebuffer.bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      allAggregationModel.draw({
        parameters: {
          clearColor: [0, 0, 0, 0],
          clearDepth: 0,
          blend: true,
          depthTest: false,
          blendEquation: [GL.FUNC_ADD, GL.MAX],
          blendFunc: [GL.ONE, GL.ONE]
        },
        uniforms: {
          uSampler: gridAggregationFramebuffer.texture,
          gridSize: gridSize
        }
      });
      allAggregrationFramebuffer.unbind();
    }
    /* eslint-disable max-statements */

  }, {
    key: "_runAggregationOnCPU",
    value: function _runAggregationOnCPU(opts) {
      var ELEMENTCOUNT = 4;
      var positions = opts.positions,
          weights = opts.weights,
          cellSize = opts.cellSize,
          projectPoints = opts.projectPoints,
          gridTransformMatrix = opts.gridTransformMatrix;
      var countsBuffer = opts.countsBuffer,
          maxCountBuffer = opts.maxCountBuffer;
      var _this$state2 = this.state,
          numCol = _this$state2.numCol,
          numRow = _this$state2.numRow; // Each element contains 4 floats to match with GPU ouput

      var counts = new Float32Array(numCol * numRow * ELEMENTCOUNT);
      var pos = positions;

      if (projectPoints) {
        this._projectPositions(opts);

        pos = this.state.projectedPositions;
      }

      counts.fill(0);
      var maxWeight = 0;
      var totalCount = 0;
      var totalWeight = 0;

      for (var index = 0; index < pos.length; index += 2) {
        var gridPos = worldToPixels([pos[index], pos[index + 1], 0], gridTransformMatrix);
        var x = gridPos[0];
        var y = gridPos[1];
        var weight = weights ? weights[index / 2] : 1;
        assert(Number.isFinite(weight));
        var colId = Math.floor(x / cellSize[0]);
        var rowId = Math.floor(y / cellSize[1]);

        if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {
          var i = (colId + rowId * numCol) * ELEMENTCOUNT;
          counts[i]++;
          counts[i + 1] += weight;
          totalCount += 1;
          totalWeight += weight;

          if (counts[i + 1] > maxWeight) {
            maxWeight = counts[i + 1];
          }
        }
      }

      var maxCountBufferData = new Float32Array(ELEMENTCOUNT); // Store total count value in Red/X channel

      maxCountBufferData[0] = totalCount; // Store total weight value in Green/Y channel

      maxCountBufferData[1] = totalWeight; // Store max weight value in alpha/W channel.

      maxCountBufferData[3] = maxWeight; // Load data to WebGL buffer.

      if (countsBuffer) {
        countsBuffer.subData({
          data: counts
        });
      } else {
        countsBuffer = new Buffer(this.gl, {
          data: counts
        });
      }

      if (maxCountBuffer) {
        maxCountBuffer.subData({
          data: maxCountBufferData
        });
      } else {
        maxCountBuffer = new Buffer(this.gl, {
          data: maxCountBufferData
        });
      }

      return {
        // Buffer objects
        countsBuffer: countsBuffer,
        maxCountBuffer: maxCountBuffer,
        // ArrayView objects
        countsData: counts,
        maxCountData: maxCountBufferData,
        // Return total aggregaton values to avoid UBO setup for WebGL1 cases
        totalCount: totalCount,
        totalWeight: totalWeight,
        maxWeight: maxWeight
      };
    }
    /* eslint-enable max-statements */

  }, {
    key: "_runAggregationOnGPU",
    value: function _runAggregationOnGPU(opts) {
      this._updateModels(opts);

      this._renderAggregateData(opts);

      return this._getAggregateData(opts);
    } // Update priveate state

  }, {
    key: "_setState",
    value: function _setState(updateObject) {
      Object.assign(this.state, updateObject);
    }
  }, {
    key: "_setupGPUResources",
    value: function _setupGPUResources() {
      var gl = this.gl;
      this.gridAggregationFramebuffer = setupFramebuffer(gl, {
        id: 'GridAggregation'
      });
      this.allAggregrationFramebuffer = setupFramebuffer(gl, {
        id: 'AllAggregation'
      });
    }
  }, {
    key: "_setupModels",
    value: function _setupModels() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.gridAggregationModel) {
        this.gridAggregationModel.delete();
      }

      this.gridAggregationModel = this._getAggregationModel(fp64);

      if (this.allAggregationModel) {
        this.allAggregationModel.delete();
      }

      this.allAggregationModel = this._getAllAggregationModel(fp64);
    }
    /* eslint-disable max-statements */

  }, {
    key: "_updateModels",
    value: function _updateModels(opts) {
      var gl = this.gl;
      var positions = opts.positions,
          positions64xyLow = opts.positions64xyLow,
          weights = opts.weights,
          changeFlags = opts.changeFlags;
      var _this$state3 = this.state,
          numCol = _this$state3.numCol,
          numRow = _this$state3.numRow;
      var _this$state4 = this.state,
          positionsBuffer = _this$state4.positionsBuffer,
          positions64xyLowBuffer = _this$state4.positions64xyLowBuffer,
          weightsBuffer = _this$state4.weightsBuffer;
      var aggregationModelAttributes = {};
      var createPos64xyLow = false;

      if (opts.fp64 !== this.state.fp64) {
        this._setupModels(opts.fp64);

        this._setState({
          fp64: opts.fp64
        });

        if (opts.fp64) {
          createPos64xyLow = true;
        }
      }

      if (changeFlags.dataChanged || !positionsBuffer) {
        if (positionsBuffer) {
          positionsBuffer.delete();
        }

        if (weightsBuffer) {
          weightsBuffer.delete();
        }

        positionsBuffer = new Buffer(gl, {
          size: 2,
          data: new Float32Array(positions)
        });
        weightsBuffer = new Buffer(gl, {
          size: 1,
          data: new Float32Array(weights)
        });
        createPos64xyLow = opts.fp64;
        Object.assign(aggregationModelAttributes, {
          positions: positionsBuffer,
          weights: weightsBuffer
        });
        this.gridAggregationModel.setVertexCount(positions.length / 2);

        this._setState({
          positionsBuffer: positionsBuffer,
          weightsBuffer: weightsBuffer
        });
      }

      if (createPos64xyLow) {
        assert(positions64xyLow);

        if (positions64xyLowBuffer) {
          positions64xyLowBuffer.delete();
        }

        positions64xyLowBuffer = new Buffer(gl, {
          size: 2,
          data: new Float32Array(positions64xyLow)
        });
        Object.assign(aggregationModelAttributes, {
          positions64xyLow: positions64xyLowBuffer
        });

        this._setState({
          positions64xyLowBuffer: positions64xyLowBuffer
        });
      }

      this.gridAggregationModel.setAttributes(aggregationModelAttributes);

      if (changeFlags.cellSizeChanged || changeFlags.viewportChanged) {
        this.allAggregationModel.setInstanceCount(numCol * numRow);
        var framebufferSize = {
          width: numCol,
          height: numRow
        };
        this.gridAggregationFramebuffer.resize(framebufferSize);
        this.allAggregrationFramebuffer.resize(framebufferSize);
      }
    }
    /* eslint-enable max-statements */

  }, {
    key: "_updateGridSize",
    value: function _updateGridSize(opts) {
      var viewport = opts.viewport,
          cellSize = opts.cellSize;
      var width = opts.width || viewport.width;
      var height = opts.height || viewport.height;
      var numCol = Math.ceil(width / cellSize[0]);
      var numRow = Math.ceil(height / cellSize[1]);

      this._setState({
        numCol: numCol,
        numRow: numRow,
        windowSize: [width, height]
      });
    }
  }]);

  return GPUGridAggregator;
}(); // Helper methods.


export { GPUGridAggregator as default };

function setupFramebuffer(gl, opts) {
  var _parameters;

  var id = opts.id;
  var texture = new Texture2D(gl, {
    data: null,
    format: GL.RGBA32F,
    type: GL.FLOAT,
    border: 0,
    mipmaps: false,
    parameters: (_parameters = {}, _defineProperty(_parameters, GL.TEXTURE_MAG_FILTER, GL.NEAREST), _defineProperty(_parameters, GL.TEXTURE_MIN_FILTER, GL.NEAREST), _parameters),
    dataFormat: GL.RGBA
  });
  var fb = new Framebuffer(gl, {
    id: id,
    attachments: _defineProperty({}, GL.COLOR_ATTACHMENT0, texture)
  });
  return fb;
}
//# sourceMappingURL=gpu-grid-aggregator.js.map