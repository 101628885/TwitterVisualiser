{"version":3,"sources":["../../../../../src/experimental/utils/gpu-grid-aggregation/grid-aggregation-utils.js"],"names":["assert","Matrix4","fp64","fp64Utils","COORDINATE_SYSTEM","fp64LowPart","R_EARTH","pointToDensityGridData","data","getPosition","cellSizeMeters","gpuGridAggregator","gpuAggregation","coordinateSystem","LNGLAT","viewport","gridData","_parseGridData","cellSize","worldOrigin","IDENTITY","gridOffset","_getGridOffset","xOffset","yOffset","width","height","opts","_getGPUAggregationParams","aggregatedData","run","positions","positions64xyLow","weights","gridTransformMatrix","useGPU","countsBuffer","maxCountBuffer","countsData","maxCountData","gridSize","gridOrigin","getWeight","yMin","Infinity","yMax","xMin","xMax","y","x","p","length","position","push","weight","Number","isFinite","latMin","latMax","centerLat","_calculateGridLatLonOffset","latitude","_calculateLatOffset","_calculateLonOffset","dy","Math","PI","lat","dx","cos","_alignToCell","inValue","sign","value","abs","floor","originX","originY","translate","ceil"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAAQC,OAAR,QAAsB,SAAtB;AACA,SAAQC,IAAI,IAAIC,SAAhB,QAAgC,SAAhC;AACA,SAAQC,iBAAR,QAAgC,wBAAhC;IACOC,W,GAAeF,S,CAAfE,W;AAEP,IAAMC,OAAO,GAAG,OAAhB,C,CAEA;;AACA,OAAO,SAASC,sBAAT,OASJ;AAAA,MARDC,IAQC,QARDA,IAQC;AAAA,MAPDC,WAOC,QAPDA,WAOC;AAAA,MANDC,cAMC,QANDA,cAMC;AAAA,MALDC,iBAKC,QALDA,iBAKC;AAAA,MAJDC,cAIC,QAJDA,cAIC;AAAA,qBAHDV,IAGC;AAAA,MAHDA,IAGC,wBAHM,KAGN;AAAA,mCAFDW,gBAEC;AAAA,MAFDA,gBAEC,sCAFkBT,iBAAiB,CAACU,MAEpC;AAAA,2BADDC,QACC;AAAA,MADDA,QACC,8BADU,IACV;;AACD,MAAMC,QAAQ,GAAGC,cAAc,CAACT,IAAD,EAAOC,WAAP,CAA/B;;AACA,MAAIS,QAAQ,GAAG,CAACR,cAAD,EAAiBA,cAAjB,CAAf;AACA,MAAIS,WAAW,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAlB;AACAnB,EAAAA,MAAM,CACJa,gBAAgB,KAAKT,iBAAiB,CAACU,MAAvC,IAAiDD,gBAAgB,KAAKT,iBAAiB,CAACgB,QADpF,CAAN;;AAGA,MAAIP,gBAAgB,KAAKT,iBAAiB,CAACU,MAA3C,EAAmD;AACjD;AACA,QAAMO,UAAU,GAAGC,cAAc,CAACN,QAAD,EAAWN,cAAX,CAAjC;;AACAQ,IAAAA,QAAQ,GAAG,CAACG,UAAU,CAACE,OAAZ,EAAqBF,UAAU,CAACG,OAAhC,CAAX;AAEAL,IAAAA,WAAW,GAAG,CAAC,CAAC,GAAF,EAAO,CAAC,EAAR,CAAd,CALiD,CAKtB;AAC5B,GAND,MAMO;AACL;AACAnB,IAAAA,MAAM,CAACa,gBAAgB,KAAKT,iBAAiB,CAACgB,QAAxC,CAAN;AAFK,QAGEK,KAHF,GAGmBV,QAHnB,CAGEU,KAHF;AAAA,QAGSC,MAHT,GAGmBX,QAHnB,CAGSW,MAHT;AAILP,IAAAA,WAAW,GAAG,CAAC,CAACM,KAAD,GAAS,CAAV,EAAa,CAACC,MAAD,GAAU,CAAvB,CAAd,CAJK,CAIoC;AAC1C;;AAED,MAAMC,IAAI,GAAGC,wBAAwB,CAAC;AAACZ,IAAAA,QAAQ,EAARA,QAAD;AAAWE,IAAAA,QAAQ,EAARA,QAAX;AAAqBC,IAAAA,WAAW,EAAXA;AAArB,GAAD,CAArC;;AAEA,MAAMU,cAAc,GAAGlB,iBAAiB,CAACmB,GAAlB,CAAsB;AAC3CC,IAAAA,SAAS,EAAEf,QAAQ,CAACe,SADuB;AAE3CC,IAAAA,gBAAgB,EAAEhB,QAAQ,CAACgB,gBAFgB;AAG3CC,IAAAA,OAAO,EAAEjB,QAAQ,CAACiB,OAHyB;AAI3Cf,IAAAA,QAAQ,EAARA,QAJ2C;AAK3CO,IAAAA,KAAK,EAAEE,IAAI,CAACF,KAL+B;AAM3CC,IAAAA,MAAM,EAAEC,IAAI,CAACD,MAN8B;AAO3CQ,IAAAA,mBAAmB,EAAEP,IAAI,CAACO,mBAPiB;AAQ3CC,IAAAA,MAAM,EAAEvB,cARmC;AAS3CV,IAAAA,IAAI,EAAJA;AAT2C,GAAtB,CAAvB;AAYA,SAAO;AACLkC,IAAAA,YAAY,EAAEP,cAAc,CAACO,YADxB;AAELC,IAAAA,cAAc,EAAER,cAAc,CAACQ,cAF1B;AAGLC,IAAAA,UAAU,EAAET,cAAc,CAACS,UAHtB;AAILC,IAAAA,YAAY,EAAEV,cAAc,CAACU,YAJxB;AAKLC,IAAAA,QAAQ,EAAEb,IAAI,CAACa,QALV;AAMLC,IAAAA,UAAU,EAAEd,IAAI,CAACc,UANZ;AAOLvB,IAAAA,QAAQ,EAARA;AAPK,GAAP;AASD,C,CAED;;AACA,SAASD,cAAT,CAAwBT,IAAxB,EAA8BC,WAA9B,EAA6D;AAAA,MAAlBiC,SAAkB,uEAAN,IAAM;AAC3D1C,EAAAA,MAAM,CAACQ,IAAI,IAAIC,WAAT,CAAN;AACA,MAAMsB,SAAS,GAAG,EAAlB;AACA,MAAMC,gBAAgB,GAAG,EAAzB;AACA,MAAMC,OAAO,GAAG,EAAhB;AAEA,MAAIU,IAAI,GAAGC,QAAX;AACA,MAAIC,IAAI,GAAG,CAACD,QAAZ;AACA,MAAIE,IAAI,GAAGF,QAAX;AACA,MAAIG,IAAI,GAAG,CAACH,QAAZ;AACA,MAAII,CAAJ;AACA,MAAIC,CAAJ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,IAAI,CAAC2C,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,QAAME,QAAQ,GAAG3C,WAAW,CAACD,IAAI,CAAC0C,CAAD,CAAL,CAA5B;AACAD,IAAAA,CAAC,GAAGG,QAAQ,CAAC,CAAD,CAAZ;AACAJ,IAAAA,CAAC,GAAGI,QAAQ,CAAC,CAAD,CAAZ;AACArB,IAAAA,SAAS,CAACsB,IAAV,CAAeJ,CAAf,EAAkBD,CAAlB;AACAhB,IAAAA,gBAAgB,CAACqB,IAAjB,CAAsBhD,WAAW,CAAC4C,CAAD,CAAjC,EAAsC5C,WAAW,CAAC2C,CAAD,CAAjD;AAEA,QAAMM,MAAM,GAAGZ,SAAS,GAAGA,SAAS,CAAClC,IAAI,CAAC0C,CAAD,CAAL,CAAZ,GAAwB,GAAhD;AACAjB,IAAAA,OAAO,CAACoB,IAAR,CAAaC,MAAb;;AAEA,QAAIC,MAAM,CAACC,QAAP,CAAgBR,CAAhB,KAAsBO,MAAM,CAACC,QAAP,CAAgBP,CAAhB,CAA1B,EAA8C;AAC5CN,MAAAA,IAAI,GAAGK,CAAC,GAAGL,IAAJ,GAAWK,CAAX,GAAeL,IAAtB;AACAE,MAAAA,IAAI,GAAGG,CAAC,GAAGH,IAAJ,GAAWG,CAAX,GAAeH,IAAtB;AAEAC,MAAAA,IAAI,GAAGG,CAAC,GAAGH,IAAJ,GAAWG,CAAX,GAAeH,IAAtB;AACAC,MAAAA,IAAI,GAAGE,CAAC,GAAGF,IAAJ,GAAWE,CAAX,GAAeF,IAAtB;AACD;AACF;;AAED,SAAO;AACLhB,IAAAA,SAAS,EAATA,SADK;AAELC,IAAAA,gBAAgB,EAAhBA,gBAFK;AAGLC,IAAAA,OAAO,EAAPA,OAHK;AAILU,IAAAA,IAAI,EAAJA,IAJK;AAKLE,IAAAA,IAAI,EAAJA,IALK;AAMLC,IAAAA,IAAI,EAAJA,IANK;AAOLC,IAAAA,IAAI,EAAJA;AAPK,GAAP;AASD;AAED;;;;;;;;AAOA,SAASzB,cAAT,CAAwBN,QAAxB,EAAkCE,QAAlC,EAA4C;AAAA,MACnCyB,IADmC,GACrB3B,QADqB,CACnC2B,IADmC;AAAA,MAC7BE,IAD6B,GACrB7B,QADqB,CAC7B6B,IAD6B;AAE1C,MAAMY,MAAM,GAAGd,IAAf;AACA,MAAMe,MAAM,GAAGb,IAAf;AACA,MAAMc,SAAS,GAAG,CAACF,MAAM,GAAGC,MAAV,IAAoB,CAAtC;AAEA,SAAOE,0BAA0B,CAAC1C,QAAD,EAAWyC,SAAX,CAAjC;AACD;AAED;;;;;;;;;AAOA,SAASC,0BAAT,CAAoC1C,QAApC,EAA8C2C,QAA9C,EAAwD;AACtD,MAAMrC,OAAO,GAAGsC,mBAAmB,CAAC5C,QAAD,CAAnC;;AACA,MAAMK,OAAO,GAAGwC,mBAAmB,CAACF,QAAD,EAAW3C,QAAX,CAAnC;;AACA,SAAO;AAACM,IAAAA,OAAO,EAAPA,OAAD;AAAUD,IAAAA,OAAO,EAAPA;AAAV,GAAP;AACD;AAED;;;;;;;;AAMA,SAASuC,mBAAT,CAA6BE,EAA7B,EAAiC;AAC/B,SAAQA,EAAE,GAAG1D,OAAN,IAAkB,MAAM2D,IAAI,CAACC,EAA7B,CAAP;AACD;AAED;;;;;;;;;;AAQA,SAASH,mBAAT,CAA6BI,GAA7B,EAAkCC,EAAlC,EAAsC;AACpC,SAASA,EAAE,GAAG9D,OAAN,IAAkB,MAAM2D,IAAI,CAACC,EAA7B,CAAD,GAAqCD,IAAI,CAACI,GAAL,CAAUF,GAAG,GAAGF,IAAI,CAACC,EAAZ,GAAkB,GAA3B,CAA5C;AACD,C,CAED;;;AACA,OAAO,SAASI,YAAT,CAAsBC,OAAtB,EAA+BrD,QAA/B,EAAyC;AAC9C,MAAMsD,IAAI,GAAGD,OAAO,GAAG,CAAV,GAAc,CAAC,CAAf,GAAmB,CAAhC;AAEA,MAAIE,KAAK,GAAGD,IAAI,GAAG,CAAP,GAAWP,IAAI,CAACS,GAAL,CAASH,OAAT,IAAoBrD,QAA/B,GAA0C+C,IAAI,CAACS,GAAL,CAASH,OAAT,CAAtD;AAEAE,EAAAA,KAAK,GAAGR,IAAI,CAACU,KAAL,CAAWF,KAAK,GAAGvD,QAAnB,IAA+BA,QAAvC;AAEA,SAAOuD,KAAK,GAAGD,IAAf;AACD,C,CAED;;AACA,SAAS5C,wBAAT,QAAqE;AAAA,MAAlCZ,QAAkC,SAAlCA,QAAkC;AAAA,MAAxBE,QAAwB,SAAxBA,QAAwB;AAAA,MAAdC,WAAc,SAAdA,WAAc;AAAA,MAC5DwB,IAD4D,GAClC3B,QADkC,CAC5D2B,IAD4D;AAAA,MACtDE,IADsD,GAClC7B,QADkC,CACtD6B,IADsD;AAAA,MAChDC,IADgD,GAClC9B,QADkC,CAChD8B,IADgD;AAAA,MAC1CC,IAD0C,GAClC/B,QADkC,CAC1C+B,IAD0C,EAGnE;AACA;AACA;AACA;;AACA,MAAM6B,OAAO,GAAGN,YAAY,CAACxB,IAAI,GAAG3B,WAAW,CAAC,CAAD,CAAnB,EAAwBD,QAAQ,CAAC,CAAD,CAAhC,CAAZ,GAAmDC,WAAW,CAAC,CAAD,CAA9E;AACA,MAAM0D,OAAO,GAAGP,YAAY,CAAC3B,IAAI,GAAGxB,WAAW,CAAC,CAAD,CAAnB,EAAwBD,QAAQ,CAAC,CAAD,CAAhC,CAAZ,GAAmDC,WAAW,CAAC,CAAD,CAA9E,CARmE,CAUnE;;AACA,MAAMe,mBAAmB,GAAG,IAAIjC,OAAJ,GAAc6E,SAAd,CAAwB,CAAC,CAAC,CAAD,GAAKF,OAAN,EAAe,CAAC,CAAD,GAAKC,OAApB,EAA6B,CAA7B,CAAxB,CAA5B,CAXmE,CAanE;;AACA,MAAMpC,UAAU,GAAG,CAACmC,OAAD,EAAUC,OAAV,CAAnB;AACA,MAAMpD,KAAK,GAAGsB,IAAI,GAAGD,IAAP,GAAc5B,QAAQ,CAAC,CAAD,CAApC;AACA,MAAMQ,MAAM,GAAGmB,IAAI,GAAGF,IAAP,GAAczB,QAAQ,CAAC,CAAD,CAArC;AAEA,MAAMsB,QAAQ,GAAG,CAACyB,IAAI,CAACc,IAAL,CAAUtD,KAAK,GAAGP,QAAQ,CAAC,CAAD,CAA1B,CAAD,EAAiC+C,IAAI,CAACc,IAAL,CAAUrD,MAAM,GAAGR,QAAQ,CAAC,CAAD,CAA3B,CAAjC,CAAjB;AAEA,SAAO;AACLuB,IAAAA,UAAU,EAAVA,UADK;AAELD,IAAAA,QAAQ,EAARA,QAFK;AAGLf,IAAAA,KAAK,EAALA,KAHK;AAILC,IAAAA,MAAM,EAANA,MAJK;AAKLQ,IAAAA,mBAAmB,EAAnBA;AALK,GAAP;AAOD","sourcesContent":["import assert from 'assert';\nimport {Matrix4} from 'math.gl';\nimport {fp64 as fp64Utils} from 'luma.gl';\nimport {COORDINATE_SYSTEM} from '../../../lib/constants';\nconst {fp64LowPart} = fp64Utils;\n\nconst R_EARTH = 6378000;\n\n// Takes data and aggregation params and returns aggregated data.\nexport function pointToDensityGridData({\n  data,\n  getPosition,\n  cellSizeMeters,\n  gpuGridAggregator,\n  gpuAggregation,\n  fp64 = false,\n  coordinateSystem = COORDINATE_SYSTEM.LNGLAT,\n  viewport = null\n}) {\n  const gridData = _parseGridData(data, getPosition);\n  let cellSize = [cellSizeMeters, cellSizeMeters];\n  let worldOrigin = [0, 0];\n  assert(\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.IDENTITY\n  );\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n    // TODO: also for COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL ?\n    const gridOffset = _getGridOffset(gridData, cellSizeMeters);\n    cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    worldOrigin = [-180, -90]; // Origin used to define grid cell boundaries\n  } else {\n    // Other co-ordiante sytems are not verified yet.\n    assert(coordinateSystem === COORDINATE_SYSTEM.IDENTITY);\n    const {width, height} = viewport;\n    worldOrigin = [-width / 2, -height / 2]; // Origin used to define grid cell boundaries\n  }\n\n  const opts = _getGPUAggregationParams({gridData, cellSize, worldOrigin});\n\n  const aggregatedData = gpuGridAggregator.run({\n    positions: gridData.positions,\n    positions64xyLow: gridData.positions64xyLow,\n    weights: gridData.weights,\n    cellSize,\n    width: opts.width,\n    height: opts.height,\n    gridTransformMatrix: opts.gridTransformMatrix,\n    useGPU: gpuAggregation,\n    fp64\n  });\n\n  return {\n    countsBuffer: aggregatedData.countsBuffer,\n    maxCountBuffer: aggregatedData.maxCountBuffer,\n    countsData: aggregatedData.countsData,\n    maxCountData: aggregatedData.maxCountData,\n    gridSize: opts.gridSize,\n    gridOrigin: opts.gridOrigin,\n    cellSize\n  };\n}\n\n// Parse input data to build positions, wights and bounding box.\nfunction _parseGridData(data, getPosition, getWeight = null) {\n  assert(data && getPosition);\n  const positions = [];\n  const positions64xyLow = [];\n  const weights = [];\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n  for (let p = 0; p < data.length; p++) {\n    const position = getPosition(data[p]);\n    x = position[0];\n    y = position[1];\n    positions.push(x, y);\n    positions64xyLow.push(fp64LowPart(x), fp64LowPart(y));\n\n    const weight = getWeight ? getWeight(data[p]) : 1.0;\n    weights.push(weight);\n\n    if (Number.isFinite(y) && Number.isFinite(x)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    positions,\n    positions64xyLow,\n    weights,\n    yMin,\n    yMax,\n    xMin,\n    xMax\n  };\n}\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} gridData - contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.\n */\n\nfunction _getGridOffset(gridData, cellSize) {\n  const {yMin, yMax} = gridData;\n  const latMin = yMin;\n  const latMax = yMax;\n  const centerLat = (latMin + latMax) / 2;\n\n  return _calculateGridLatLonOffset(cellSize, centerLat);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function _alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n// Calculate grid parameters\nfunction _getGPUAggregationParams({gridData, cellSize, worldOrigin}) {\n  const {yMin, yMax, xMin, xMax} = gridData;\n\n  // NOTE: this alignment will match grid cell boundaries with existing CPU implementation\n  // this gurantees identical aggregation results when switching between CPU and GPU aggregation.\n  // Also gurantees same cell boundaries, when overlapping between two different layers (like ScreenGrid and Contour)\n  // We first move worldOrigin to [0, 0], align the lower bounding box , then move worldOrigin to its original value.\n  const originX = _alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];\n  const originY = _alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1];\n\n  // Setup transformation matrix so that every point is in +ve range\n  const gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]);\n\n  // const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n  const gridOrigin = [originX, originY];\n  const width = xMax - xMin + cellSize[0];\n  const height = yMax - yMin + cellSize[1];\n\n  const gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];\n\n  return {\n    gridOrigin,\n    gridSize,\n    width,\n    height,\n    gridTransformMatrix\n  };\n}\n"],"file":"grid-aggregation-utils.js"}