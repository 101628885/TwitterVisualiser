// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { drawPickingBuffer, getPixelRatio } from './draw-layers';
import log from '../utils/log';
import assert from '../utils/assert';
var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};
/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate

export function pickObject(gl, _ref) {
  var layers = _ref.layers,
      viewports = _ref.viewports,
      x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      layerFilter = _ref.layerFilter,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 1 : _ref$depth,
      mode = _ref.mode,
      onViewportActive = _ref.onViewportActive,
      pickingFBO = _ref.pickingFBO,
      lastPickedInfo = _ref.lastPickedInfo,
      useDevicePixels = _ref.useDevicePixels;
  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({
    useDevicePixels: useDevicePixels
  });
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);
  var deviceRect = getPickingRect({
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius,
    deviceWidth: pickingFBO.width,
    deviceHeight: pickingFBO.height
  });
  var result = [];
  var affectedLayers = {};

  for (var i = 0; i < depth; i++) {
    var pickedColors = deviceRect && drawAndSamplePickingBuffer(gl, {
      layers: layers,
      viewports: viewports,
      onViewportActive: onViewportActive,
      useDevicePixels: useDevicePixels,
      pickingFBO: pickingFBO,
      deviceRect: deviceRect,
      layerFilter: layerFilter,
      redrawReason: mode
    });
    var pickInfo = pickedColors && getClosestFromPickingBuffer(gl, {
      pickedColors: pickedColors,
      layers: layers,
      deviceX: deviceX,
      deviceY: deviceY,
      deviceRadius: deviceRadius,
      deviceRect: deviceRect
    }) || NO_PICKED_OBJECT; // Only exclude if we need to run picking again.
    // We need to run picking again if an object is detected AND
    // we have not exhausted the requested depth.

    if (pickInfo.pickedColor && i + 1 < depth) {
      var layerId = pickInfo.pickedColor[3] - 1;

      if (!affectedLayers[layerId]) {
        // backup original colors
        affectedLayers[layerId] = layers[layerId].copyPickingColors();
      }

      layers[layerId].clearPickingColor(pickInfo.pickedColor);
    } // This logic needs to run even if no object is picked.


    var processedPickInfos = processPickInfo({
      pickInfo: pickInfo,
      lastPickedInfo: lastPickedInfo,
      mode: mode,
      layers: layers,
      viewports: viewports,
      x: x,
      y: y,
      deviceX: deviceX,
      deviceY: deviceY,
      pixelRatio: pixelRatio
    });

    if (processedPickInfos) {
      processedPickInfos.forEach(function (info) {
        return result.push(info);
      });
    } // If no object is picked stop.


    if (!pickInfo.pickedColor) {
      break;
    }
  } // reset only affected buffers


  Object.keys(affectedLayers).forEach(function (layerId) {
    return layers[layerId].restorePickingColors(affectedLayers[layerId]);
  });
  return result;
} // Pick all objects within the given bounding box

export function pickVisibleObjects(gl, _ref2) {
  var layers = _ref2.layers,
      viewports = _ref2.viewports,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      mode = _ref2.mode,
      layerFilter = _ref2.layerFilter,
      onViewportActive = _ref2.onViewportActive,
      pickingFBO = _ref2.pickingFBO,
      useDevicePixels = _ref2.useDevicePixels;
  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({
    useDevicePixels: useDevicePixels
  });
  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);
  var deviceRect = {
    x: deviceLeft,
    y: deviceTop,
    width: deviceRight - deviceLeft,
    height: deviceBottom - deviceTop
  };
  var pickedColors = drawAndSamplePickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    useDevicePixels: useDevicePixels,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: mode
  });
  var pickInfos = getUniquesFromPickingBuffer(gl, {
    pickedColors: pickedColors,
    layers: layers
  }); // Only return unique infos, identified by info.object

  var uniqueInfos = new Map();
  pickInfos.forEach(function (pickInfo) {
    var info = {
      color: pickInfo.pickedColor,
      layer: null,
      index: pickInfo.pickedObjectIndex,
      picked: true,
      x: x,
      y: y,
      width: width,
      height: height,
      pixelRatio: pixelRatio
    };
    info = getLayerPickingInfo({
      layer: pickInfo.pickedLayer,
      info: info,
      mode: mode
    });

    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });
  return Array.from(uniqueInfos.values());
} // HELPER METHODS
// returns pickedColor or null if no pickable layers found.

function drawAndSamplePickingBuffer(gl, _ref3) {
  var layers = _ref3.layers,
      viewports = _ref3.viewports,
      onViewportActive = _ref3.onViewportActive,
      useDevicePixels = _ref3.useDevicePixels,
      pickingFBO = _ref3.pickingFBO,
      deviceRect = _ref3.deviceRect,
      layerFilter = _ref3.layerFilter,
      redrawReason = _ref3.redrawReason;
  assert(deviceRect);
  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');
  var pickableLayers = layers.filter(function (layer) {
    return layer.isPickable();
  });

  if (pickableLayers.length < 1) {
    return null;
  }

  drawPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    useDevicePixels: useDevicePixels,
    pickingFBO: pickingFBO,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: redrawReason
  }); // Read from an already rendered picking buffer
  // Returns an Uint8ClampedArray of picked pixels

  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;
  var pickedColors = new Uint8Array(width * height * 4);
  pickingFBO.readPixels({
    x: x,
    y: y,
    width: width,
    height: height,
    pixelArray: pickedColors
  });
  return pickedColors;
} // Indentifies which viewport, if any corresponds to x and y
// Returns first viewport if no match
// TODO - need to determine which viewport we are in
// TODO - document concept of "primary viewport" that matches all coords?
// TODO - static method on Viewport class?


function getViewportFromCoordinates(_ref4) {
  var viewports = _ref4.viewports;
  var viewport = viewports[0];
  return viewport;
} // Calculate a picking rect centered on deviceX and deviceY and clipped to device
// Returns null if pixel is outside of device


function getPickingRect(_ref5) {
  var deviceX = _ref5.deviceX,
      deviceY = _ref5.deviceY,
      deviceRadius = _ref5.deviceRadius,
      deviceWidth = _ref5.deviceWidth,
      deviceHeight = _ref5.deviceHeight;
  var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight; // x, y out of bounds.

  if (!valid) {
    return null;
  } // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]


  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;
  var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
} // TODO - break this monster function into 3+ parts


function processPickInfo(_ref6) {
  var pickInfo = _ref6.pickInfo,
      lastPickedInfo = _ref6.lastPickedInfo,
      mode = _ref6.mode,
      layers = _ref6.layers,
      viewports = _ref6.viewports,
      x = _ref6.x,
      y = _ref6.y,
      deviceX = _ref6.deviceX,
      deviceY = _ref6.deviceY,
      pixelRatio = _ref6.pixelRatio;
  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;
  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id; // proceed only if picked object changed

    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });

        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      } // Update layer manager context


      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var viewport = getViewportFromCoordinates({
    viewports: viewports
  }); // TODO - add coords

  var baseInfo = {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x: x,
    y: y,
    pixel: [x, y],
    lngLat: viewport && viewport.unproject([x, y]),
    devicePixel: [deviceX, deviceY],
    pixelRatio: pixelRatio
  }; // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern

  var infos = new Map();
  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({
      layer: layer,
      info: info,
      mode: mode
    }); // This guarantees that there will be only one copy of info for
    // one composite layer

    if (info) {
      infos.set(info.layer.id, info);
    }

    var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;
    layer.setModuleParameters({
      pickingSelectedColor: pickingSelectedColor
    });
  });
  var unhandledPickInfos = callLayerPickingCallbacks(infos, mode);
  return unhandledPickInfos;
} // Per-layer event handlers (e.g. onClick, onHover) are provided by the
// user and out of deck.gl's control. It's very much possible that
// the user calls React lifecycle methods in these function, such as
// ReactComponent.setState(). React lifecycle methods sometimes induce
// a re-render and re-generation of props of deck.gl and its layers,
// which invalidates all layers currently passed to this very function.
// Therefore, per-layer event handlers must be invoked at the end
// of the picking operation. NO operation that relies on the states of current
// layers should be called after this code.


function callLayerPickingCallbacks(infos, mode) {
  var unhandledPickInfos = [];
  infos.forEach(function (info) {
    var handled = false;

    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);
        break;

      case 'hover':
        handled = info.layer.props.onHover(info);
        break;

      case 'query':
        break;

      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });
  return unhandledPickInfos;
}
/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */


export function getClosestFromPickingBuffer(gl, _ref7) {
  var pickedColors = _ref7.pickedColors,
      layers = _ref7.layers,
      deviceX = _ref7.deviceX,
      deviceY = _ref7.deviceY,
      deviceRadius = _ref7.deviceRadius,
      deviceRect = _ref7.deviceRect;
  assert(pickedColors); // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]

  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestPixelIndex = -1;
  var i = 0;

  for (var row = 0; row < height; row++) {
    var dy = row + y - deviceY;
    var dy2 = dy * dy;

    if (dy2 > minSquareDistanceToCenter) {
      // skip this row
      i += 4 * width;
    } else {
      for (var col = 0; col < width; col++) {
        // Decode picked layer from color
        var pickedLayerIndex = pickedColors[i + 3] - 1;

        if (pickedLayerIndex >= 0) {
          var dx = col + x - deviceX;
          var d2 = dx * dx + dy2;

          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }

        i += 4;
      }
    }
  }

  if (closestPixelIndex >= 0) {
    // Decode picked object index from color
    var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;

    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    var pickedLayer = layers[_pickedLayerIndex];

    if (pickedLayer) {
      var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
      return {
        pickedColor: pickedColor,
        pickedLayer: pickedLayer,
        pickedObjectIndex: pickedObjectIndex
      };
    }

    log.error('Picked non-existent layer. Is picking buffer corrupt?')();
  }

  return NO_PICKED_OBJECT;
}
/* eslint-enable max-depth, max-statements */

/**
 * Examines a picking buffer for unique colors
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */

function getUniquesFromPickingBuffer(gl, _ref8) {
  var pickedColors = _ref8.pickedColors,
      layers = _ref8.layers;
  var uniqueColors = new Map(); // Traverse all pixels in picking results and get unique colors

  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(','); // eslint-disable-next-line

        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex]; // eslint-disable-next-line

          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor: pickedColor,
              pickedLayer: pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            log.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
} // Walk up the layer composite chain to populate the info object


function getLayerPickingInfo(_ref9) {
  var layer = _ref9.layer,
      info = _ref9.info,
      mode = _ref9.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer; // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer

    info = layer.pickLayer({
      info: info,
      mode: mode,
      sourceLayer: sourceLayer
    });
    layer = layer.parent;
  }

  return info;
}
//# sourceMappingURL=pick-layers.js.map