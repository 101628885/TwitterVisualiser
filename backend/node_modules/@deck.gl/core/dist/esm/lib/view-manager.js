function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import assert from '../utils/assert';
import { deepEqual } from '../utils/deep-equal';
import View from '../views/view';
import Viewport from '../viewports/viewport';
import log from '../utils/log';
import { flatten } from '../utils/flatten';

var ViewManager =
/*#__PURE__*/
function () {
  function ViewManager() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ViewManager);

    // List of view descriptors, gets re-evaluated when width/height changes
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this._viewports = []; // Generated viewports

    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'Initial render';
    this._needsUpdate = true;
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractiveStateChange: props.onInteractiveStateChange
    };
    Object.seal(this); // Init with default map viewport

    this.setProps(props);
  }

  _createClass(ViewManager, [{
    key: "finalize",
    value: function finalize() {
      for (var key in this.controllers) {
        if (this.controllers[key]) {
          this.controllers[key].finalize();
        }
      }

      this.controllers = {};
    } // Check if a redraw is needed

  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearRedrawFlags = _ref.clearRedrawFlags,
          clearRedrawFlags = _ref$clearRedrawFlags === void 0 ? true : _ref$clearRedrawFlags;

      var redraw = this._needsRedraw;

      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    } // Layers will be redrawn (in next animation frame)

  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    } // Layers will be updated deeply (in next animation frame)
    // Potentially regenerating attributes and sub layers

  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    /** Get a set of viewports for a given width and height
     * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
     * @param rect (object, optional) - filter the viewports
     *   + not provided - return all viewports
     *   + {x, y} - only return viewports that contain this pixel
     *   + {x, y, width, height} - only return viewports that overlap with this rectangle
     */

  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      if (rect) {
        return this._viewports.filter(function (viewport) {
          return viewport.containsPixel(rect);
        });
      }

      return this._viewports;
    }
  }, {
    key: "getViews",
    value: function getViews() {
      var viewMap = {};
      this.views.forEach(function (view) {
        viewMap[view.id] = view;
      });
      return viewMap;
    } // Resolves a viewId string to a View, if already a View returns it.

  }, {
    key: "getView",
    value: function getView(viewOrViewId) {
      return typeof viewOrViewId === 'string' ? this.views.find(function (view) {
        return view.id === viewOrViewId;
      }) : viewOrViewId;
    } // Returns the viewState for a specific viewId. Matches the viewState by
    // 1. view.viewStateId
    // 2. view.id
    // 3. root viewState
    // then applies the view's filter if any

  }, {
    key: "getViewState",
    value: function getViewState(viewId) {
      var view = this.getView(viewId); // Backward compatibility: view state for single view

      var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: "project",
    value: function project(xyz) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        topLeft: true
      };
      var viewports = this.getViewports();

      for (var i = viewports.length - 1; i >= 0; --i) {
        var viewport = viewports[i];

        if (viewport.contains(xyz, opts)) {
          return viewport.project(xyz, opts);
        }
      }

      return null;
    }
    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether origin is top left
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: "unproject",
    value: function unproject(xyz, opts) {
      var viewports = this.getViewports();

      for (var i = viewports.length - 1; i >= 0; --i) {
        var viewport = viewports[i];

        if (viewport.containsPixel(xyz, opts)) {
          return viewport.unproject(xyz);
        }
      }

      return null;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('views' in props) {
        this._setViews(props.views);
      } // TODO - support multiple view states


      if ('viewState' in props) {
        this._setViewState(props.viewState);
      }

      if ('width' in props || 'height' in props) {
        this._setSize(props.width, props.height);
      } // Important: avoid invoking _update() inside itself
      // Nested updates result in unexpected side effects inside _rebuildViewports()
      // when using auto control in pure-js


      if (!this._isUpdating) {
        this._update();
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      this._isUpdating = true; // Only rebuild viewports if the update flag is set

      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      } // If viewport transition(s) are triggered during viewports update, controller(s)
      // will immediately call `onViewStateChange` which calls `viewManager.setProps` again.


      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      }

      this._isUpdating = false;
    }
  }, {
    key: "_setSize",
    value: function _setSize(width, height) {
      assert(Number.isFinite(width) && Number.isFinite(height));

      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate('Size changed');
      }
    } // Update the view descriptor list and set change flag if needed
    // Does not actually rebuild the `Viewport`s until `getViewports` is called

  }, {
    key: "_setViews",
    value: function _setViews(views) {
      // DEPRECATED: Ensure any "naked" Viewports are wrapped in View instances
      views = flatten(views, {
        filter: Boolean
      }).map(function (view) {
        return view instanceof Viewport ? new View({
          viewportInstance: view
        }) : view;
      });

      var viewsChanged = this._diffViews(views, this.views);

      if (viewsChanged) {
        this.setNeedsUpdate('views changed');
      }

      this.views = views;
    }
  }, {
    key: "_setViewState",
    value: function _setViewState(viewState) {
      if (viewState) {
        var viewStateChanged = !deepEqual(viewState, this.viewState);

        if (viewStateChanged) {
          this.setNeedsUpdate('viewState changed');
        }

        this.viewState = viewState;
      } else {
        log.warn('setting null viewState')();
      }
    } //
    // PRIVATE METHODS
    //

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(viewId, event) {
      event.viewId = viewId;

      this._eventCallbacks.onViewStateChange(event);
    }
  }, {
    key: "_createController",
    value: function _createController(props) {
      var Controller = props.type;
      var controller = new Controller(Object.assign({
        eventManager: this._eventManager,
        // Set an internal callback that calls the prop callback if provided
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractiveStateChange
      }, props));
      return controller;
    }
  }, {
    key: "_updateController",
    value: function _updateController(view, viewState, viewport, controller) {
      if (view.controller) {
        var controllerProps = Object.assign({}, view.controller, view.defaultState, viewState, {
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        }); // TODO - check if view / controller type has changed, and replace the controller

        if (controller) {
          controller.setProps(controllerProps);
        } else {
          controller = this._createController(controllerProps);
        }

        return controller;
      }

      return null;
    } // Rebuilds viewports from descriptors towards a certain window size

  }, {
    key: "_rebuildViewports",
    value: function _rebuildViewports() {
      var _this = this;

      var width = this.width,
          height = this.height,
          views = this.views;
      var oldControllers = this.controllers;
      this.controllers = {};
      this._viewports = views.map(function (view) {
        var viewState = _this.getViewState(view);

        var viewport = view.makeViewport({
          width: width,
          height: height,
          viewState: viewState
        }); // Update the controller

        _this.controllers[view.id] = _this._updateController(view, viewState, viewport, oldControllers[view.id]);
        return viewport;
      }); // Remove unused controllers

      for (var id in oldControllers) {
        if (oldControllers[id] && !this.controllers[id]) {
          oldControllers[id].finalize();
        }
      }

      this._buildViewportMap();
    }
  }, {
    key: "_buildViewportMap",
    value: function _buildViewportMap() {
      var _this2 = this;

      // Build a view id to view index
      this._viewportMap = {};

      this._viewports.forEach(function (viewport) {
        if (viewport.id) {
          // TODO - issue warning if multiple viewports use same id
          _this2._viewportMap[viewport.id] = _this2._viewportMap[viewport.id] || viewport;
        }
      });
    } // Check if viewport array has changed, returns true if any change
    // Note that descriptors can be the same

  }, {
    key: "_diffViews",
    value: function _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }

      return newViews.some(function (_, i) {
        return !newViews[i].equals(oldViews[i]);
      });
    }
  }]);

  return ViewManager;
}();

export { ViewManager as default };
//# sourceMappingURL=view-manager.js.map