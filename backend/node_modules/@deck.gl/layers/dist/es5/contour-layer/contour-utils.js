"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateContours = generateContours;

var MarchingSquares = _interopRequireWildcard(require("./marching-squares"));

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

// Given all the cell weights, generates contours for each threshold.
function generateContours(_ref) {
  var thresholds = _ref.thresholds,
      colors = _ref.colors,
      cellWeights = _ref.cellWeights,
      gridSize = _ref.gridSize,
      gridOrigin = _ref.gridOrigin,
      cellSize = _ref.cellSize;
  var contourSegments = [];
  var width = gridSize[0];
  var height = gridSize[1];
  thresholds.forEach(function (threshold, index) {
    for (var x = -1; x < width; x++) {
      for (var y = -1; y < height; y++) {
        // Get the MarchingSquares code based on neighbor cell weights.
        var code = MarchingSquares.getCode({
          cellWeights: cellWeights,
          thresholdValue: threshold,
          x: x,
          y: y,
          width: width,
          height: height
        }); // Get the intersection vertices based on MarchingSquares code.

        var vertices = MarchingSquares.getVertices({
          gridOrigin: gridOrigin,
          cellSize: cellSize,
          x: x,
          y: y,
          width: width,
          height: height,
          code: code
        }); // We should always get even number of vertices

        (0, _assert.default)(vertices.length % 2 === 0);

        for (var i = 0; i < vertices.length; i += 2) {
          contourSegments.push({
            start: vertices[i],
            end: vertices[i + 1],
            threshold: threshold
          });
        }
      }
    }
  });
  return contourSegments;
}
//# sourceMappingURL=contour-utils.js.map