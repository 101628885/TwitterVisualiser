"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCode = getCode;
exports.getVertices = getVertices;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// All utility mehtods needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
// Table to map code to the intersection offsets
// All offsets are relative to the center of marching cell (which is top right corner of grid-cell)
var OFFSET = {
  N: [0, 0.5],
  E: [0.5, 0],
  S: [0, -0.5],
  W: [-0.5, 0]
}; // Note: above wiki page invertes white/black dots for generating the code, we don't

var CODE_OFFSET_MAP = {
  0: [],
  1: [[OFFSET.W, OFFSET.S]],
  2: [[OFFSET.S, OFFSET.E]],
  3: [[OFFSET.W, OFFSET.E]],
  4: [[OFFSET.N, OFFSET.E]],
  5: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],
  6: [[OFFSET.N, OFFSET.S]],
  7: [[OFFSET.W, OFFSET.N]],
  8: [[OFFSET.W, OFFSET.N]],
  9: [[OFFSET.N, OFFSET.S]],
  10: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],
  11: [[OFFSET.N, OFFSET.E]],
  12: [[OFFSET.W, OFFSET.E]],
  13: [[OFFSET.S, OFFSET.E]],
  14: [[OFFSET.W, OFFSET.S]],
  15: []
}; // Returns marching square code for given cell

/* eslint-disable complexity */

function getCode(_ref) {
  var cellWeights = _ref.cellWeights,
      thresholdValue = _ref.thresholdValue,
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height;
  // Assumptions
  // Origin is on bottom-left , and X increase to right, Y to top
  // When processing one cell, we process 4 cells, by extending row to top and on column to right
  // to create a 2X2 cell grid
  (0, _assert.default)(x >= -1 && x < width);
  (0, _assert.default)(y >= -1 && y < height);
  var isLeftBoundary = x < 0;
  var isRightBoundary = x >= width - 1;
  var isBottomBoundary = y < 0;
  var isTopBoundary = y >= height - 1;
  var top = isLeftBoundary || isTopBoundary ? 0 : cellWeights[(y + 1) * width + x] - thresholdValue >= 0 ? 1 : 0;
  var topRight = isRightBoundary || isTopBoundary ? 0 : cellWeights[(y + 1) * width + x + 1] - thresholdValue >= 0 ? 1 : 0;
  var right = isRightBoundary ? 0 : cellWeights[y * width + x + 1] - thresholdValue >= 0 ? 1 : 0;
  var current = isLeftBoundary || isBottomBoundary ? 0 : cellWeights[y * width + x] - thresholdValue >= 0 ? 1 : 0;
  var code = top << 3 | topRight << 2 | right << 1 | current;
  (0, _assert.default)(code >= 0 && code < 16);
  return code;
}
/* eslint-enable complexity */
// Returns intersection vertices for given cellindex
// [x, y] refers current marchng cell, reference vertex is always top-right corner


function getVertices(_ref2) {
  var gridOrigin = _ref2.gridOrigin,
      cellSize = _ref2.cellSize,
      x = _ref2.x,
      y = _ref2.y,
      code = _ref2.code;
  var offsets = CODE_OFFSET_MAP[code]; // Reference vertex is at top-right move to top-right corner

  (0, _assert.default)(x >= -1);
  (0, _assert.default)(y >= -1);
  var rX = (x + 1) * cellSize[0];
  var rY = (y + 1) * cellSize[1];
  var refVertexX = gridOrigin[0] + rX;
  var refVertexY = gridOrigin[1] + rY;
  var vertices = [];
  offsets.forEach(function (xyOffsets) {
    xyOffsets.forEach(function (offset) {
      var vX = refVertexX + offset[0] * cellSize[0];
      var vY = refVertexY + offset[1] * cellSize[1];
      vertices.push([vX, vY]);
    });
  });
  return vertices;
}
//# sourceMappingURL=marching-squares.js.map