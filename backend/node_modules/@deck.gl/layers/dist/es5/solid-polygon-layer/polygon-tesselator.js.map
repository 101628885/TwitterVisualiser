{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["fillArray","experimental","fp64LowPart","fp64Module","getPickingColor","index","DEFAULT_COLOR","PolygonTesselator","polygons","IndexType","map","polygon","Polygon","normalize","pointCount","getPointCount","bufferLayout","getVertexCount","Uint16Array","Error","attributes","pickingColors","calculatePickingColors","fp64","extruded","positions","Float32Array","vertexValid","Uint8ClampedArray","fill","positions64xyLow","updatePositions","cache","calculateIndices","key","getElevation","x","values","updateElevations","getColor","updateColors","reduce","points","getTriangleCount","triangles","getPolygonOffsets","offsets","Array","length","offset","forEach","i","Uint32Array","indexCount","attribute","polygonIndex","getSurfaceIndices","loop","vertex","vertexIndex","y","z","elevations","complexPolygon","height","vertexCount","target","source","start","count","colors","color","isNaN"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {experimental} from '@deck.gl/core';\nconst {fillArray} = experimental;\nimport {fp64 as fp64Module} from 'luma.gl';\nconst {fp64LowPart} = fp64Module;\n\n// Maybe deck.gl or luma.gl needs to export this\nfunction getPickingColor(index) {\n  index++;\n  return [index & 255, (index >> 8) & 255, (index >> 16) & 255];\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport class PolygonTesselator {\n  constructor({polygons, IndexType}) {\n    // Normalize all polygons\n    polygons = polygons.map(polygon => Polygon.normalize(polygon));\n\n    // Count all polygon vertices\n    const pointCount = getPointCount(polygons);\n\n    this.polygons = polygons;\n    this.pointCount = pointCount;\n    this.bufferLayout = polygons.map(polygon => Polygon.getVertexCount(polygon));\n    this.IndexType = IndexType;\n\n    // TODO: dynamically decide IndexType in tesselator?\n    // Check if the vertex count excedes index type limit\n    if (IndexType === Uint16Array && pointCount > 65535) {\n      throw new Error(\"Vertex count exceeds browser's limit\");\n    }\n\n    this.attributes = {\n      pickingColors: calculatePickingColors({polygons, pointCount})\n    };\n  }\n\n  updatePositions({fp64, extruded}) {\n    const {attributes, polygons, pointCount} = this;\n\n    attributes.positions = attributes.positions || new Float32Array(pointCount * 3);\n    attributes.vertexValid = attributes.vertexValid || new Uint8ClampedArray(pointCount).fill(1);\n\n    if (fp64) {\n      // We only need x, y component\n      attributes.positions64xyLow = attributes.positions64xyLow || new Float32Array(pointCount * 2);\n    }\n\n    updatePositions({cache: attributes, polygons, extruded, fp64});\n  }\n\n  indices() {\n    const {polygons, IndexType} = this;\n    return calculateIndices({polygons, IndexType});\n  }\n\n  positions() {\n    return this.attributes.positions;\n  }\n  positions64xyLow() {\n    return this.attributes.positions64xyLow;\n  }\n\n  vertexValid() {\n    return this.attributes.vertexValid;\n  }\n\n  elevations({key = 'elevations', getElevation = x => 100} = {}) {\n    const {attributes, polygons, pointCount} = this;\n    const values = updateElevations({cache: attributes[key], polygons, pointCount, getElevation});\n    attributes[key] = values;\n    return values;\n  }\n\n  colors({key = 'colors', getColor = x => DEFAULT_COLOR} = {}) {\n    const {attributes, polygons, pointCount} = this;\n    const values = updateColors({cache: attributes[key], polygons, pointCount, getColor});\n    attributes[key] = values;\n    return values;\n  }\n\n  pickingColors() {\n    return this.attributes.pickingColors;\n  }\n}\n\n// Count number of points in a list of complex polygons\nfunction getPointCount(polygons) {\n  return polygons.reduce((points, polygon) => points + Polygon.getVertexCount(polygon), 0);\n}\n\n// COunt number of triangles in a list of complex polygons\nfunction getTriangleCount(polygons) {\n  return polygons.reduce((triangles, polygon) => triangles + Polygon.getTriangleCount(polygon), 0);\n}\n\n// Returns the offsets of each complex polygon in the combined array of all polygons\nfunction getPolygonOffsets(polygons) {\n  const offsets = new Array(polygons.length + 1);\n  offsets[0] = 0;\n  let offset = 0;\n  polygons.forEach((polygon, i) => {\n    offset += Polygon.getVertexCount(polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n}\n\nfunction calculateIndices({polygons, IndexType = Uint32Array}) {\n  // Calculate length of index array (3 * number of triangles)\n  const indexCount = 3 * getTriangleCount(polygons);\n  const offsets = getPolygonOffsets(polygons);\n\n  // Allocate the attribute\n  const attribute = new IndexType(indexCount);\n\n  // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n  let i = 0;\n  polygons.forEach((polygon, polygonIndex) => {\n    for (const index of Polygon.getSurfaceIndices(polygon)) {\n      attribute[i++] = index + offsets[polygonIndex];\n    }\n  });\n\n  return attribute;\n}\n\nfunction updatePositions({\n  cache: {positions, positions64xyLow, vertexValid},\n  polygons,\n  extruded,\n  fp64\n}) {\n  // Flatten out all the vertices of all the sub subPolygons\n  let i = 0;\n  polygons.forEach((polygon, polygonIndex) => {\n    polygon.forEach(loop => {\n      loop.forEach((vertex, vertexIndex) => {\n        // eslint-disable-line\n        const x = vertex[0];\n        const y = vertex[1];\n        const z = vertex[2] || 0;\n\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n        if (fp64) {\n          positions64xyLow[i * 2] = fp64LowPart(x);\n          positions64xyLow[i * 2 + 1] = fp64LowPart(y);\n        }\n        i++;\n      });\n      /* We are reusing the some buffer for `nextPositions` by offsetting one vertex\n       * to the left. As a result,\n       * the last vertex of each loop overlaps with the first vertex of the next loop.\n       * `vertexValid` is used to mark the end of each loop so we don't draw these\n       * segments:\n        positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n        nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n        vertexValid    1  1  1  1  0  1  1  0  1 ...\n       */\n      vertexValid[i - 1] = 0;\n    });\n  });\n}\n\nfunction updateElevations({cache, polygons, pointCount, getElevation}) {\n  const elevations = cache || new Float32Array(pointCount);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    const height = getElevation(polygonIndex);\n\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: elevations, source: [height], start: i, count: vertexCount});\n    i += vertexCount;\n  });\n  return elevations;\n}\n\nfunction updateColors({cache, polygons, pointCount, getColor}) {\n  const colors = cache || new Uint8ClampedArray(pointCount * 4);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    const color = getColor(polygonIndex);\n    if (isNaN(color[3])) {\n      color[3] = 255;\n    }\n\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: colors, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return colors;\n}\n\nfunction calculatePickingColors({polygons, pointCount}) {\n  const attribute = new Uint8ClampedArray(pointCount * 3);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    const color = getPickingColor(polygonIndex);\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: attribute, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}\n"],"file":"polygon-tesselator.js"}