"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSimple = isSimple;
exports.normalize = normalize;
exports.getVertexCount = getVertexCount;
exports.getTriangleCount = getTriangleCount;
exports.getSurfaceIndices = getSurfaceIndices;

var _core = require("@deck.gl/core");

var _earcut = _interopRequireDefault(require("earcut"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var flattenVertices = _core.experimental.flattenVertices;

// Basic polygon support
//
// Handles simple and complex polygons
// Simple polygons are arrays of vertices, implicitly "closed"
// Complex polygons are arrays of simple polygons, with the first polygon
// representing the outer hull and other polygons representing holes

/**
 * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)
 * @param {Array} polygon - either a complex or simple polygon
 * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)
 */
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
/**
 * Ensure that all simple polygons have the same start and end vertex
 */


function closeLoop(simplePolygon) {
  // check if first and last vertex are the same
  var p0 = simplePolygon[0];
  var p1 = simplePolygon[simplePolygon.length - 1];

  if (p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2]) {
    return simplePolygon;
  } // duplicate the starting vertex at end


  return simplePolygon.concat([p0]);
}
/**
 * Normalize to ensure that all polygons in a list are complex - simplifies processing
 * @param {Array} polygon - either a complex or a simple polygon
 * @param {Object} opts
 * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed
 * @return {Array} - returns a complex polygons
 */


function normalize(polygon) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$dimensions = _ref.dimensions,
      dimensions = _ref$dimensions === void 0 ? 3 : _ref$dimensions;

  return isSimple(polygon) ? [closeLoop(polygon)] : polygon.map(closeLoop);
}
/**
 * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)
 * @param {Array} polygon - either a complex or simple polygon
 * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)
 */


function getVertexCount(polygon) {
  return isSimple(polygon) ? polygon.length : polygon.reduce(function (length, simplePolygon) {
    return length + simplePolygon.length;
  }, 0);
} // Return number of triangles needed to tesselate the polygon


function getTriangleCount(polygon) {
  var triangleCount = 0;
  var first = true;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = normalize(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var simplePolygon = _step.value;
      var size = simplePolygon.length;

      if (first) {
        triangleCount += size >= 3 ? size - 2 : 0;
      } else {
        triangleCount += size + 1;
      }

      first = false;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return triangleCount;
} // Returns the offset of each hole polygon in the flattened array for that polygon


function getHoleIndices(complexPolygon) {
  var holeIndices = null;

  if (complexPolygon.length > 1) {
    var polygonStartIndex = 0;
    holeIndices = [];
    complexPolygon.forEach(function (polygon) {
      polygonStartIndex += polygon.length;
      holeIndices.push(polygonStartIndex);
    }); // Last element points to end of the flat array, remove it

    holeIndices.pop();
  }

  return holeIndices;
}
/*
 * Get vertex indices for drawing complexPolygon mesh
 * @private
 * @param {[Number,Number,Number][][]} complexPolygon
 * @returns {[Number]} indices
 */


function getSurfaceIndices(complexPolygon) {
  // Prepare an array of hole indices as expected by earcut
  var holeIndices = getHoleIndices(complexPolygon); // Flatten the polygon as expected by earcut

  var verts = flattenVertices(complexPolygon, {
    dimensions: 2,
    result: []
  }); // Let earcut triangulate the polygon

  return (0, _earcut.default)(verts, holeIndices, 2);
}
//# sourceMappingURL=polygon.js.map