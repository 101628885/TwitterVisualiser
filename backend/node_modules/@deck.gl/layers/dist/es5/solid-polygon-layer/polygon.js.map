{"version":3,"sources":["../../../src/solid-polygon-layer/polygon.js"],"names":["flattenVertices","experimental","isSimple","polygon","length","Number","isFinite","closeLoop","simplePolygon","p0","p1","concat","normalize","dimensions","map","getVertexCount","reduce","getTriangleCount","triangleCount","first","size","getHoleIndices","complexPolygon","holeIndices","polygonStartIndex","forEach","push","pop","getSurfaceIndices","verts","result"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {experimental} from '@deck.gl/core';\nconst {flattenVertices} = experimental;\nimport earcut from 'earcut';\n\n// Basic polygon support\n//\n// Handles simple and complex polygons\n// Simple polygons are arrays of vertices, implicitly \"closed\"\n// Complex polygons are arrays of simple polygons, with the first polygon\n// representing the outer hull and other polygons representing holes\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nexport function isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Ensure that all simple polygons have the same start and end vertex\n */\nfunction closeLoop(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  if (p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2]) {\n    return simplePolygon;\n  }\n  // duplicate the starting vertex at end\n  return simplePolygon.concat([p0]);\n}\n\n/**\n * Normalize to ensure that all polygons in a list are complex - simplifies processing\n * @param {Array} polygon - either a complex or a simple polygon\n * @param {Object} opts\n * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed\n * @return {Array} - returns a complex polygons\n */\nexport function normalize(polygon, {dimensions = 3} = {}) {\n  return isSimple(polygon) ? [closeLoop(polygon)] : polygon.map(closeLoop);\n}\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nexport function getVertexCount(polygon) {\n  return isSimple(polygon)\n    ? polygon.length\n    : polygon.reduce((length, simplePolygon) => length + simplePolygon.length, 0);\n}\n\n// Return number of triangles needed to tesselate the polygon\nexport function getTriangleCount(polygon) {\n  let triangleCount = 0;\n  let first = true;\n  for (const simplePolygon of normalize(polygon)) {\n    const size = simplePolygon.length;\n    if (first) {\n      triangleCount += size >= 3 ? size - 2 : 0;\n    } else {\n      triangleCount += size + 1;\n    }\n    first = false;\n  }\n  return triangleCount;\n}\n\n// Returns the offset of each hole polygon in the flattened array for that polygon\nfunction getHoleIndices(complexPolygon) {\n  let holeIndices = null;\n  if (complexPolygon.length > 1) {\n    let polygonStartIndex = 0;\n    holeIndices = [];\n    complexPolygon.forEach(polygon => {\n      polygonStartIndex += polygon.length;\n      holeIndices.push(polygonStartIndex);\n    });\n    // Last element points to end of the flat array, remove it\n    holeIndices.pop();\n  }\n  return holeIndices;\n}\n\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\nexport function getSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  const holeIndices = getHoleIndices(complexPolygon);\n  // Flatten the polygon as expected by earcut\n  const verts = flattenVertices(complexPolygon, {dimensions: 2, result: []});\n  // Let earcut triangulate the polygon\n  return earcut(verts, holeIndices, 2);\n}\n"],"file":"polygon.js"}