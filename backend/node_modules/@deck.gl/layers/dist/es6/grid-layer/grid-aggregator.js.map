{"version":3,"sources":["../../../src/grid-layer/grid-aggregator.js"],"names":["R_EARTH","pointToDensityGridData","points","cellSize","getPosition","_pointsToGridHashing","gridHash","gridOffset","layerData","_getGridLayerDataFromGridHash","latMin","Infinity","latMax","pLat","pt","Number","isFinite","centerLat","_calculateGridLatLonOffset","xOffset","yOffset","lat","lng","latIdx","Math","floor","lonIdx","key","count","push","Object","keys","reduce","accu","i","idxs","split","parseInt","assign","index","position","latitude","_calculateLatOffset","_calculateLonOffset","dy","PI","dx","cos"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {Iterable} points\n * @param {number} cellSize - cell size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridData(points, cellSize, getPosition) {\n  const {gridHash, gridOffset} = _pointsToGridHashing(points, cellSize, getPosition);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n\n  return {\n    gridOffset,\n    layerData\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\nfunction _pointsToGridHashing(points = [], cellSize, getPosition) {\n  // find the geometric center of sample points\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n\n  for (const pt of points) {\n    pLat = getPosition(pt)[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n\n  const centerLat = (latMin + latMax) / 2;\n\n  const gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  // calculate count per cell\n  const gridHash = {};\n  for (const pt of points) {\n    const lat = getPosition(pt)[1];\n    const lng = getPosition(pt)[0];\n\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n      const key = `${latIdx}-${lonIdx}`;\n\n      gridHash[key] = gridHash[key] || {count: 0, points: []};\n      gridHash[key].count += 1;\n      gridHash[key].points.push(pt);\n    }\n  }\n\n  return {gridHash, gridOffset};\n}\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(\n      Object.assign(\n        {\n          index: i,\n          position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n        },\n        gridHash[key]\n      )\n    );\n\n    return accu;\n  }, []);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n"],"file":"grid-aggregator.js"}