function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, Geometry, hasFeature, FEATURES } from 'luma.gl'; // Polygon geometry generation is managed by the polygon tesselator

import { PolygonTesselator } from './polygon-tesselator';
import vs from './solid-polygon-layer-vertex.glsl';
import fs from './solid-polygon-layer-fragment.glsl';
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,
  // elevation multiplier
  elevationScale: 1,
  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return f.polygon;
  },
  // Accessor for extrusion height
  getElevation: 1000,
  // Accessor for colors
  getFillColor: DEFAULT_COLOR,
  getLineColor: DEFAULT_COLOR,
  // Optional settings for 'lighting' shader module
  lightSettings: {}
};
var ATTRIBUTE_TRANSITION = {
  enter: function enter(value, chunk) {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

var SolidPolygonLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(SolidPolygonLayer).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: vs,
        fs: fs,
        modules: [projectModule, 'lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      this.setState({
        numInstances: 0,
        IndexType: hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      });
      var attributeManager = this.getAttributeManager();
      var noAlloc = true;
      attributeManager.remove(['instancePickingColors']);
      /* eslint-disable max-len */

      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc: noAlloc
        },
        positions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPolygon',
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        positions64xyLow: {
          size: 2,
          update: this.calculatePositionsLow,
          noAlloc: noAlloc
        },
        vertexValid: {
          size: 1,
          type: GL.UNSIGNED_BYTE,
          update: this.calculateVertexValid,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getElevation',
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          defaultValue: DEFAULT_COLOR,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          defaultValue: DEFAULT_COLOR,
          noAlloc: noAlloc
        },
        pickingColors: {
          size: 3,
          type: GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: noAlloc
        }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          extruded = _this$props.extruded,
          filled = _this$props.filled,
          wireframe = _this$props.wireframe,
          elevationScale = _this$props.elevationScale;
      var _this$state = this.state,
          topModel = _this$state.topModel,
          sideModel = _this$state.sideModel;
      var renderUniforms = Object.assign({}, uniforms, {
        extruded: Boolean(extruded),
        elevationScale: elevationScale
      }); // Note: the order is important

      if (sideModel) {
        sideModel.setUniforms(renderUniforms);

        if (wireframe) {
          sideModel.setDrawMode(GL.LINE_STRIP);
          sideModel.render({
            isWireframe: true
          });
        }

        if (filled) {
          sideModel.setDrawMode(GL.TRIANGLE_FAN);
          sideModel.render({
            isWireframe: false
          });
        }
      }

      if (topModel) {
        topModel.render(renderUniforms);
      }
    }
  }, {
    key: "updateState",
    value: function updateState(updateParams) {
      _get(_getPrototypeOf(SolidPolygonLayer.prototype), "updateState", this).call(this, updateParams);

      this.updateGeometry(updateParams);
      var props = updateParams.props,
          oldProps = updateParams.oldProps;
      var attributeManager = this.getAttributeManager();
      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;

      if (regenerateModels) {
        if (this.state.models) {
          this.state.models.forEach(function (model) {
            return model.delete();
          });
        }

        this.setState(this._getModels(this.context.gl));
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "updateGeometry",
    value: function updateGeometry(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;
      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon); // When the geometry config  or the data is changed,
      // tessellator needs to be invoked

      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        var polygonTesselator = this._getPolygonTesselator(polygons, this.state.IndexType);

        this.setState({
          polygonTesselator: polygonTesselator,
          numInstances: polygonTesselator.pointCount
        });
        this.getAttributeManager().invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: this.use64bitPositions(),
          extruded: props.extruded
        });
      }
    } // "Experimental" method indended to make it easier to support non-nested arrays in subclasses

  }, {
    key: "_getPolygonTesselator",
    value: function _getPolygonTesselator(polygons, IndexType) {
      return new PolygonTesselator({
        polygons: polygons,
        IndexType: this.state.IndexType
      });
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(props) {
      _get(_getPrototypeOf(SolidPolygonLayer.prototype), "updateAttributes", this).call(this, props);

      var attributes = this.getAttributeManager().getChangedAttributes({
        clearChangedFlags: true
      });
      var _this$state2 = this.state,
          topModel = _this$state2.topModel,
          sideModel = _this$state2.sideModel,
          vertexCount = _this$state2.vertexCount,
          numInstances = _this$state2.numInstances;

      if (topModel) {
        topModel.setVertexCount(vertexCount);
        topModel.setAttributes(attributes);
      }

      if (sideModel) {
        // Remove one to account for the offset
        sideModel.setInstanceCount(numInstances - 1);
        var newAttributes = {};

        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];

          if (attributeName !== 'indices') {
            // Apply layout override to the attribute.
            newAttributes[attributeName] = Object.assign({}, attribute, {
              isInstanced: true,
              buffer: attribute.getBuffer()
            });
          }
        }

        if (newAttributes.positions) {
          newAttributes.nextPositions = Object.assign({}, newAttributes.positions, {
            id: 'nextPositions',
            offset: 12 // 1 vertex * 3 floats * 4 bits

          });
        }

        if (newAttributes.positions64xyLow) {
          newAttributes.nextPositions64xyLow = Object.assign({}, newAttributes.positions64xyLow, {
            id: 'nextPositions64xyLow',
            offset: 8 // 1 vertex * 2 floats * 4 bits

          });
        }

        sideModel.setAttributes(newAttributes);
      }
    }
  }, {
    key: "_getModels",
    value: function _getModels(gl) {
      var _this$props2 = this.props,
          id = _this$props2.id,
          filled = _this$props2.filled,
          extruded = _this$props2.extruded;
      var topModel;
      var sideModel;

      if (filled) {
        topModel = new Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-top"),
          geometry: new Geometry({
            drawMode: GL.TRIANGLES,
            attributes: {
              vertexPositions: {
                size: 2,
                constant: true,
                value: new Float32Array([0, 1])
              },
              nextPositions: {
                size: 3,
                constant: true,
                value: new Float32Array(3)
              },
              nextPositions64xyLow: {
                size: 2,
                constant: true,
                value: new Float32Array(2)
              }
            }
          }),
          uniforms: {
            isWireframe: false,
            isSideVertex: false
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }

      if (extruded) {
        sideModel = new Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-side"),
          geometry: new Geometry({
            drawMode: GL.LINES,
            vertexCount: 4,
            attributes: {
              // top right - top left - bootom left - bottom right
              vertexPositions: {
                size: 2,
                value: new Float32Array([1, 1, 0, 1, 0, 0, 1, 0])
              }
            }
          }),
          uniforms: {
            isSideVertex: true
          },
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [sideModel, topModel].filter(Boolean),
        topModel: topModel,
        sideModel: sideModel
      };
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      var vertexCount = attribute.value.length / attribute.size;
      this.setState({
        vertexCount: vertexCount
      });
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.positions();
    }
  }, {
    key: "calculatePositionsLow",
    value: function calculatePositionsLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: "calculateVertexValid",
    value: function calculateVertexValid(attribute) {
      attribute.value = this.state.polygonTesselator.vertexValid();
    }
  }, {
    key: "calculateElevations",
    value: function calculateElevations(attribute) {
      var _this = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      var _this$props3 = this.props,
          extruded = _this$props3.extruded,
          _getElevation = _this$props3.getElevation;

      if (extruded && typeof _getElevation === 'function') {
        attribute.constant = false;
        attribute.value = polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _getElevation(_this.props.data[polygonIndex]);
          }
        });
      } else {
        var elevation = extruded ? _getElevation : 0;
        attribute.constant = true;
        attribute.value = new Float32Array([elevation]);
      }
    }
  }, {
    key: "calculateFillColors",
    value: function calculateFillColors(attribute) {
      var _this2 = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this2.props.getFillColor(_this2.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: "calculateLineColors",
    value: function calculateLineColors(attribute) {
      var _this3 = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getLineColor(_this3.props.data[polygonIndex]);
        }
      });
    } // Override the default picking colors calculation

  }, {
    key: "calculatePickingColors",
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(Layer);

export { SolidPolygonLayer as default };
SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=solid-polygon-layer.js.map