"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _core = require("@deck.gl/core");

var _extractJsxLayers = _interopRequireDefault(require("./utils/extract-jsx-layers"));

var _inheritsFrom = require("./utils/inherits-from");

var _evaluateChildren = _interopRequireDefault(require("./utils/evaluate-children"));

var _autobind = _interopRequireDefault(require("./utils/autobind"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var propTypes = _core.Deck.getPropTypes(_propTypes.default);

var defaultProps = _core.Deck.defaultProps;

var DeckGL =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(DeckGL, _React$PureComponent);

  function DeckGL(props) {
    var _this;

    _classCallCheck(this, DeckGL);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeckGL).call(this, props));
    _this.state = {
      width: 0,
      height: 0,
      viewState: props.initialViewState
    };
    _this.children = [];
    (0, _autobind.default)(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(DeckGL, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Allows a subclass of Deck to be used
      // TODO - update propTypes / defaultProps?
      var DeckClass = this.props.Deck || _core.Deck; // DEVTOOLS can cause this to be called twice

      this.deck = this.deck || new DeckClass(Object.assign({}, this.props, {
        initialViewState: null,
        canvas: this.deckCanvas,
        viewState: this._getViewState(this.props),
        // Note: If Deck event handling change size or view state, it calls onResize to update
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deck.finalize();
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      return this.deck.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds
      });
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? 10 : _ref2$depth;
      return this.deck.pickMultipleObjects({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        depth: depth
      });
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;
      return this.deck.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
    }
  }, {
    key: "queryObject",
    value: function queryObject(opts) {
      _core.log.removed('queryObject', 'pickObject')();
    }
  }, {
    key: "queryVisibleObjects",
    value: function queryVisibleObjects(opts) {
      _core.log.removed('queryVisibleObjects', 'pickObjects')();
    } // Callbacks
    // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onResize",
    value: function _onResize(params) {
      this.setState(params);
      this.props.onResize(params);
    } // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      // Let app know that view state is changing, and give it a chance to change it
      var viewState = this.props.onViewStateChange(params) || params.viewState; // If initialViewState was set on creation, auto track position

      if (this.state.viewState) {
        this.setState({
          viewState: Object.assign({}, this.state.viewState, _defineProperty({}, params.viewId, viewState))
        });
      }
    } // Private Helpers
    // 1. Extract any JSX layers from the react children
    // 2. Handle any backwards compatiblity props for React layer
    // Needs to be called both from initial mount, and when new props arrive

  }, {
    key: "_updateFromProps",
    value: function _updateFromProps(nextProps) {
      if (!this.deck) {
        return;
      }

      if (nextProps.viewports || nextProps.viewport) {
        _core.log.removed('DeckGL.viewport(s)', 'DeckGL.views')();
      } // extract any deck.gl layers masquerading as react elements from props.children


      var _extractJSXLayers = (0, _extractJsxLayers.default)(nextProps),
          layers = _extractJSXLayers.layers,
          views = _extractJSXLayers.views,
          children = _extractJSXLayers.children;

      var deckProps = Object.assign({}, nextProps, {
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize,
        layers: layers,
        views: views
      });

      var viewState = this._getViewState(nextProps);

      if (viewState) {
        deckProps.viewState = viewState;
      }

      this.deck.setProps(deckProps);
      this.children = children;
    } // Supports old "geospatial view state as separate props" style (React only!)

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {
        if ('maxZoom' in props || 'minZoom' in props) {
          _core.log.removed('maxZoom/minZoom', 'viewState');
        }

        var latitude = props.latitude,
            longitude = props.longitude,
            zoom = props.zoom,
            _props$pitch = props.pitch,
            pitch = _props$pitch === void 0 ? 0 : _props$pitch,
            _props$bearing = props.bearing,
            bearing = _props$bearing === void 0 ? 0 : _props$bearing;
        return {
          latitude: latitude,
          longitude: longitude,
          zoom: zoom,
          pitch: pitch,
          bearing: bearing
        };
      }

      return props.viewState || this.state.viewState;
    } // Iterate over views and reposition children associated with views
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: "_positionChildrenUnderViews",
    value: function _positionChildrenUnderViews(children) {
      var _ref4 = this.deck || {},
          viewManager = _ref4.viewManager;

      if (!viewManager || !viewManager.views.length) {
        return [];
      }

      var defaultViewId = viewManager.views[0].id;
      return children.map(function (child, i) {
        if (child.props.viewportId) {
          _core.log.removed('viewportId', '<View>')();
        }

        if (child.props.viewId) {
          _core.log.removed('viewId', '<View>')();
        } // Unless child is a View, position / render as part of the default view


        var viewId = defaultViewId;
        var viewChildren = child;

        if ((0, _inheritsFrom.inheritsFrom)(child.type, _core.View)) {
          viewId = child.props.id || defaultViewId;
          viewChildren = child.props.children;
        }

        var viewport = viewManager.getViewport(viewId);
        var viewState = viewManager.getViewState(viewId); // Drop (auto-hide) elements with viewId that are not matched by any current view

        if (!viewport) {
          return null;
        } // Resolve potentially relative dimensions using the deck.gl container size


        var x = viewport.x,
            y = viewport.y,
            width = viewport.width,
            height = viewport.height;
        viewChildren = (0, _evaluateChildren.default)(viewChildren, {
          x: x,
          y: y,
          width: width,
          height: height,
          viewport: viewport,
          viewState: viewState
        });
        var style = {
          position: 'absolute',
          left: x,
          top: y,
          width: width,
          height: height
        };
        var key = "view-child-".concat(viewId, "-").concat(i);
        return (0, _react.createElement)('div', {
          key: key,
          id: key,
          style: style
        }, viewChildren);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      // TODO - expensive to update on every render?
      this._updateFromProps(this.props); // Render the background elements (typically react-map-gl instances)
      // using the view descriptors


      var children = this._positionChildrenUnderViews(this.children); // TODO - this styling is enforced for correct positioning with children
      // It can override the styling set by `Deck`, this should be consolidated.
      // Note that width and height are handled by deck.gl


      var style = Object.assign({}, {
        position: 'absolute',
        left: 0,
        top: 0
      }, this.props.style);
      var canvas = (0, _react.createElement)('canvas', {
        ref: function ref(c) {
          return _this2.deckCanvas = c;
        },
        key: 'deck-canvas',
        id: this.props.id,
        style: style
      }); // Render deck.gl as last child

      children.push(canvas);
      return (0, _react.createElement)('div', {
        id: 'deckgl-wrapper'
      }, children);
    }
  }]);

  return DeckGL;
}(_react.default.PureComponent);

exports.default = DeckGL;
DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWNrZ2wuanMiXSwibmFtZXMiOlsicHJvcFR5cGVzIiwiRGVjayIsImdldFByb3BUeXBlcyIsIlByb3BUeXBlcyIsImRlZmF1bHRQcm9wcyIsIkRlY2tHTCIsInByb3BzIiwic3RhdGUiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdTdGF0ZSIsImluaXRpYWxWaWV3U3RhdGUiLCJjaGlsZHJlbiIsIkRlY2tDbGFzcyIsImRlY2siLCJPYmplY3QiLCJhc3NpZ24iLCJjYW52YXMiLCJkZWNrQ2FudmFzIiwiX2dldFZpZXdTdGF0ZSIsIm9uVmlld1N0YXRlQ2hhbmdlIiwiX29uVmlld1N0YXRlQ2hhbmdlIiwib25SZXNpemUiLCJfb25SZXNpemUiLCJmaW5hbGl6ZSIsIngiLCJ5IiwicmFkaXVzIiwibGF5ZXJJZHMiLCJwaWNrT2JqZWN0IiwiZGVwdGgiLCJwaWNrTXVsdGlwbGVPYmplY3RzIiwicGlja09iamVjdHMiLCJvcHRzIiwibG9nIiwicmVtb3ZlZCIsInBhcmFtcyIsInNldFN0YXRlIiwidmlld0lkIiwibmV4dFByb3BzIiwidmlld3BvcnRzIiwidmlld3BvcnQiLCJsYXllcnMiLCJ2aWV3cyIsImRlY2tQcm9wcyIsInNldFByb3BzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwidmlld01hbmFnZXIiLCJsZW5ndGgiLCJkZWZhdWx0Vmlld0lkIiwiaWQiLCJtYXAiLCJjaGlsZCIsImkiLCJ2aWV3cG9ydElkIiwidmlld0NoaWxkcmVuIiwidHlwZSIsIlZpZXciLCJnZXRWaWV3cG9ydCIsImdldFZpZXdTdGF0ZSIsInN0eWxlIiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwia2V5IiwiX3VwZGF0ZUZyb21Qcm9wcyIsIl9wb3NpdGlvbkNoaWxkcmVuVW5kZXJWaWV3cyIsInJlZiIsImMiLCJwdXNoIiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBb0JBOztBQUNB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QUEsRUFBRSxFQUFFLEtBQUtoRCxLQUFMLENBQVdnRCxFQUhzQjtBQUlyQ1UsUUFBQUEsS0FBSyxFQUFMQTtBQUpxQyxPQUF4QixDQUFmLENBYk8sQ0FvQlA7O0FBQ0FwRCxNQUFBQSxRQUFRLENBQUM2RCxJQUFULENBQWN4RCxNQUFkO0FBRUEsYUFBTywwQkFBYyxLQUFkLEVBQXFCO0FBQUNxQyxRQUFBQSxFQUFFLEVBQUU7QUFBTCxPQUFyQixFQUE2QzFDLFFBQTdDLENBQVA7QUFDRDs7OztFQTVNaUM4RCxlQUFNQyxhOzs7QUErTTFDdEUsTUFBTSxDQUFDTCxTQUFQLEdBQW1CQSxTQUFuQjtBQUNBSyxNQUFNLENBQUNELFlBQVAsR0FBc0JBLFlBQXRCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCwge2NyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge0RlY2ssIFZpZXcsIGxvZ30gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgZXh0cmFjdEpTWExheWVycyBmcm9tICcuL3V0aWxzL2V4dHJhY3QtanN4LWxheWVycyc7XG5pbXBvcnQge2luaGVyaXRzRnJvbX0gZnJvbSAnLi91dGlscy9pbmhlcml0cy1mcm9tJztcbmltcG9ydCBldmFsdWF0ZUNoaWxkcmVuIGZyb20gJy4vdXRpbHMvZXZhbHVhdGUtY2hpbGRyZW4nO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vdXRpbHMvYXV0b2JpbmQnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSBEZWNrLmdldFByb3BUeXBlcyhQcm9wVHlwZXMpO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSBEZWNrLmRlZmF1bHRQcm9wcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVja0dMIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHZpZXdTdGF0ZTogcHJvcHMuaW5pdGlhbFZpZXdTdGF0ZVxuICAgIH07XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgLy8gQWxsb3dzIGEgc3ViY2xhc3Mgb2YgRGVjayB0byBiZSB1c2VkXG4gICAgLy8gVE9ETyAtIHVwZGF0ZSBwcm9wVHlwZXMgLyBkZWZhdWx0UHJvcHM/XG4gICAgY29uc3QgRGVja0NsYXNzID0gdGhpcy5wcm9wcy5EZWNrIHx8IERlY2s7XG5cbiAgICAvLyBERVZUT09MUyBjYW4gY2F1c2UgdGhpcyB0byBiZSBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLmRlY2sgPVxuICAgICAgdGhpcy5kZWNrIHx8XG4gICAgICBuZXcgRGVja0NsYXNzKFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgaW5pdGlhbFZpZXdTdGF0ZTogbnVsbCxcbiAgICAgICAgICBjYW52YXM6IHRoaXMuZGVja0NhbnZhcyxcbiAgICAgICAgICB2aWV3U3RhdGU6IHRoaXMuX2dldFZpZXdTdGF0ZSh0aGlzLnByb3BzKSxcbiAgICAgICAgICAvLyBOb3RlOiBJZiBEZWNrIGV2ZW50IGhhbmRsaW5nIGNoYW5nZSBzaXplIG9yIHZpZXcgc3RhdGUsIGl0IGNhbGxzIG9uUmVzaXplIHRvIHVwZGF0ZVxuICAgICAgICAgIG9uVmlld1N0YXRlQ2hhbmdlOiB0aGlzLl9vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgICAgICBvblJlc2l6ZTogdGhpcy5fb25SZXNpemVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRlY2suZmluYWxpemUoKTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICBwaWNrT2JqZWN0KHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrT2JqZWN0KHt4LCB5LCByYWRpdXMsIGxheWVySWRzfSk7XG4gIH1cblxuICBwaWNrTXVsdGlwbGVPYmplY3RzKHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGwsIGRlcHRoID0gMTB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrTXVsdGlwbGVPYmplY3RzKHt4LCB5LCByYWRpdXMsIGxheWVySWRzLCBkZXB0aH0pO1xuICB9XG5cbiAgcGlja09iamVjdHMoe3gsIHksIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucGlja09iamVjdHMoe3gsIHksIHdpZHRoLCBoZWlnaHQsIGxheWVySWRzfSk7XG4gIH1cblxuICBxdWVyeU9iamVjdChvcHRzKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3F1ZXJ5T2JqZWN0JywgJ3BpY2tPYmplY3QnKSgpO1xuICB9XG5cbiAgcXVlcnlWaXNpYmxlT2JqZWN0cyhvcHRzKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3F1ZXJ5VmlzaWJsZU9iamVjdHMnLCAncGlja09iamVjdHMnKSgpO1xuICB9XG5cbiAgLy8gQ2FsbGJhY2tzXG5cbiAgLy8gRm9yd2FyZCBjYWxsYmFjayBhbmQgdGhlbiBjYWxsIGZvcmNlVXBkYXRlIHRvIGd1YXJhbnRlZSB0aGF0IHN1YiBjb21wb25lbnRzIHVwZGF0ZVxuICBfb25SZXNpemUocGFyYW1zKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShwYXJhbXMpO1xuICAgIHRoaXMucHJvcHMub25SZXNpemUocGFyYW1zKTtcbiAgfVxuXG4gIC8vIEZvcndhcmQgY2FsbGJhY2sgYW5kIHRoZW4gY2FsbCBmb3JjZVVwZGF0ZSB0byBndWFyYW50ZWUgdGhhdCBzdWIgY29tcG9uZW50cyB1cGRhdGVcbiAgX29uVmlld1N0YXRlQ2hhbmdlKHBhcmFtcykge1xuICAgIC8vIExldCBhcHAga25vdyB0aGF0IHZpZXcgc3RhdGUgaXMgY2hhbmdpbmcsIGFuZCBnaXZlIGl0IGEgY2hhbmNlIHRvIGNoYW5nZSBpdFxuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHRoaXMucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UocGFyYW1zKSB8fCBwYXJhbXMudmlld1N0YXRlO1xuXG4gICAgLy8gSWYgaW5pdGlhbFZpZXdTdGF0ZSB3YXMgc2V0IG9uIGNyZWF0aW9uLCBhdXRvIHRyYWNrIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuc3RhdGUudmlld1N0YXRlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmlld1N0YXRlOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnZpZXdTdGF0ZSwge1xuICAgICAgICAgIFtwYXJhbXMudmlld0lkXTogdmlld1N0YXRlXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlIEhlbHBlcnNcblxuICAvLyAxLiBFeHRyYWN0IGFueSBKU1ggbGF5ZXJzIGZyb20gdGhlIHJlYWN0IGNoaWxkcmVuXG4gIC8vIDIuIEhhbmRsZSBhbnkgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBwcm9wcyBmb3IgUmVhY3QgbGF5ZXJcbiAgLy8gTmVlZHMgdG8gYmUgY2FsbGVkIGJvdGggZnJvbSBpbml0aWFsIG1vdW50LCBhbmQgd2hlbiBuZXcgcHJvcHMgYXJyaXZlXG4gIF91cGRhdGVGcm9tUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKCF0aGlzLmRlY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLnZpZXdwb3J0cyB8fCBuZXh0UHJvcHMudmlld3BvcnQpIHtcbiAgICAgIGxvZy5yZW1vdmVkKCdEZWNrR0wudmlld3BvcnQocyknLCAnRGVja0dMLnZpZXdzJykoKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGFueSBkZWNrLmdsIGxheWVycyBtYXNxdWVyYWRpbmcgYXMgcmVhY3QgZWxlbWVudHMgZnJvbSBwcm9wcy5jaGlsZHJlblxuICAgIGNvbnN0IHtsYXllcnMsIHZpZXdzLCBjaGlsZHJlbn0gPSBleHRyYWN0SlNYTGF5ZXJzKG5leHRQcm9wcyk7XG5cbiAgICBjb25zdCBkZWNrUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMsIHtcbiAgICAgIG9uVmlld1N0YXRlQ2hhbmdlOiB0aGlzLl9vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgIG9uUmVzaXplOiB0aGlzLl9vblJlc2l6ZSxcbiAgICAgIGxheWVycyxcbiAgICAgIHZpZXdzXG4gICAgfSk7XG5cbiAgICBjb25zdCB2aWV3U3RhdGUgPSB0aGlzLl9nZXRWaWV3U3RhdGUobmV4dFByb3BzKTtcbiAgICBpZiAodmlld1N0YXRlKSB7XG4gICAgICBkZWNrUHJvcHMudmlld1N0YXRlID0gdmlld1N0YXRlO1xuICAgIH1cblxuICAgIHRoaXMuZGVjay5zZXRQcm9wcyhkZWNrUHJvcHMpO1xuXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG5cbiAgLy8gU3VwcG9ydHMgb2xkIFwiZ2Vvc3BhdGlhbCB2aWV3IHN0YXRlIGFzIHNlcGFyYXRlIHByb3BzXCIgc3R5bGUgKFJlYWN0IG9ubHkhKVxuICBfZ2V0Vmlld1N0YXRlKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy52aWV3U3RhdGUgJiYgJ2xhdGl0dWRlJyBpbiBwcm9wcyAmJiAnbG9uZ2l0dWRlJyBpbiBwcm9wcyAmJiAnem9vbScgaW4gcHJvcHMpIHtcbiAgICAgIGlmICgnbWF4Wm9vbScgaW4gcHJvcHMgfHwgJ21pblpvb20nIGluIHByb3BzKSB7XG4gICAgICAgIGxvZy5yZW1vdmVkKCdtYXhab29tL21pblpvb20nLCAndmlld1N0YXRlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgcGl0Y2ggPSAwLCBiZWFyaW5nID0gMH0gPSBwcm9wcztcbiAgICAgIHJldHVybiB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgcGl0Y2gsIGJlYXJpbmd9O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMudmlld1N0YXRlIHx8IHRoaXMuc3RhdGUudmlld1N0YXRlO1xuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHZpZXdzIGFuZCByZXBvc2l0aW9uIGNoaWxkcmVuIGFzc29jaWF0ZWQgd2l0aCB2aWV3c1xuICAvLyBUT0RPIC0gQ2FuIHdlIHN1cHBseSBhIHNpbWlsYXIgZnVuY3Rpb24gZm9yIHRoZSBub24tUmVhY3QgY2FzZT9cbiAgX3Bvc2l0aW9uQ2hpbGRyZW5VbmRlclZpZXdzKGNoaWxkcmVuKSB7XG4gICAgY29uc3Qge3ZpZXdNYW5hZ2VyfSA9IHRoaXMuZGVjayB8fCB7fTtcblxuICAgIGlmICghdmlld01hbmFnZXIgfHwgIXZpZXdNYW5hZ2VyLnZpZXdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRWaWV3SWQgPSB2aWV3TWFuYWdlci52aWV3c1swXS5pZDtcblxuICAgIHJldHVybiBjaGlsZHJlbi5tYXAoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQucHJvcHMudmlld3BvcnRJZCkge1xuICAgICAgICBsb2cucmVtb3ZlZCgndmlld3BvcnRJZCcsICc8Vmlldz4nKSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnByb3BzLnZpZXdJZCkge1xuICAgICAgICBsb2cucmVtb3ZlZCgndmlld0lkJywgJzxWaWV3PicpKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubGVzcyBjaGlsZCBpcyBhIFZpZXcsIHBvc2l0aW9uIC8gcmVuZGVyIGFzIHBhcnQgb2YgdGhlIGRlZmF1bHQgdmlld1xuICAgICAgbGV0IHZpZXdJZCA9IGRlZmF1bHRWaWV3SWQ7XG4gICAgICBsZXQgdmlld0NoaWxkcmVuID0gY2hpbGQ7XG4gICAgICBpZiAoaW5oZXJpdHNGcm9tKGNoaWxkLnR5cGUsIFZpZXcpKSB7XG4gICAgICAgIHZpZXdJZCA9IGNoaWxkLnByb3BzLmlkIHx8IGRlZmF1bHRWaWV3SWQ7XG4gICAgICAgIHZpZXdDaGlsZHJlbiA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHZpZXdNYW5hZ2VyLmdldFZpZXdwb3J0KHZpZXdJZCk7XG4gICAgICBjb25zdCB2aWV3U3RhdGUgPSB2aWV3TWFuYWdlci5nZXRWaWV3U3RhdGUodmlld0lkKTtcblxuICAgICAgLy8gRHJvcCAoYXV0by1oaWRlKSBlbGVtZW50cyB3aXRoIHZpZXdJZCB0aGF0IGFyZSBub3QgbWF0Y2hlZCBieSBhbnkgY3VycmVudCB2aWV3XG4gICAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNvbHZlIHBvdGVudGlhbGx5IHJlbGF0aXZlIGRpbWVuc2lvbnMgdXNpbmcgdGhlIGRlY2suZ2wgY29udGFpbmVyIHNpemVcbiAgICAgIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHZpZXdwb3J0O1xuXG4gICAgICB2aWV3Q2hpbGRyZW4gPSBldmFsdWF0ZUNoaWxkcmVuKHZpZXdDaGlsZHJlbiwge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdmlld1N0YXRlXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3R5bGUgPSB7cG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHgsIHRvcDogeSwgd2lkdGgsIGhlaWdodH07XG4gICAgICBjb25zdCBrZXkgPSBgdmlldy1jaGlsZC0ke3ZpZXdJZH0tJHtpfWA7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge2tleSwgaWQ6IGtleSwgc3R5bGV9LCB2aWV3Q2hpbGRyZW4pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIC8vIFRPRE8gLSBleHBlbnNpdmUgdG8gdXBkYXRlIG9uIGV2ZXJ5IHJlbmRlcj9cbiAgICB0aGlzLl91cGRhdGVGcm9tUHJvcHModGhpcy5wcm9wcyk7XG5cbiAgICAvLyBSZW5kZXIgdGhlIGJhY2tncm91bmQgZWxlbWVudHMgKHR5cGljYWxseSByZWFjdC1tYXAtZ2wgaW5zdGFuY2VzKVxuICAgIC8vIHVzaW5nIHRoZSB2aWV3IGRlc2NyaXB0b3JzXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuVW5kZXJWaWV3cyh0aGlzLmNoaWxkcmVuKTtcblxuICAgIC8vIFRPRE8gLSB0aGlzIHN0eWxpbmcgaXMgZW5mb3JjZWQgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcgd2l0aCBjaGlsZHJlblxuICAgIC8vIEl0IGNhbiBvdmVycmlkZSB0aGUgc3R5bGluZyBzZXQgYnkgYERlY2tgLCB0aGlzIHNob3VsZCBiZSBjb25zb2xpZGF0ZWQuXG4gICAgLy8gTm90ZSB0aGF0IHdpZHRoIGFuZCBoZWlnaHQgYXJlIGhhbmRsZWQgYnkgZGVjay5nbFxuICAgIGNvbnN0IHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAwLCB0b3A6IDB9LCB0aGlzLnByb3BzLnN0eWxlKTtcblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogYyA9PiAodGhpcy5kZWNrQ2FudmFzID0gYyksXG4gICAgICBrZXk6ICdkZWNrLWNhbnZhcycsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHN0eWxlXG4gICAgfSk7XG5cbiAgICAvLyBSZW5kZXIgZGVjay5nbCBhcyBsYXN0IGNoaWxkXG4gICAgY2hpbGRyZW4ucHVzaChjYW52YXMpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtpZDogJ2RlY2tnbC13cmFwcGVyJ30sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==