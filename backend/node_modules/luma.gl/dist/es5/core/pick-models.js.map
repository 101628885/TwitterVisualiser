{"version":3,"sources":["../../../src/core/pick-models.js"],"names":["getDevicePixelRatio","window","devicePixelRatio","pickModels","gl","props","models","position","uniforms","parameters","settings","useDevicePixels","framebuffer","context","x","y","resize","width","canvas","height","dpr","deviceX","deviceY","group","Group","children","traverseReverse","model","pickable","color","depth","setUniforms","picking_uActive","draw","Object","assign","readPixels","format","type","isPicked"],"mappings":"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","sourcesContent":["/* global window */\nimport {clear, isWebGL} from '../webgl';\nimport Group from './group';\nimport assert from '../utils/assert';\n\nfunction getDevicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n}\n\nexport default function pickModels(gl, props) {\n  const {\n    models,\n    position,\n    uniforms = {}, // eslint-disable-line\n    parameters = {},\n    settings,\n    useDevicePixels = true,\n    framebuffer,\n    context\n  } = props;\n\n  assert(isWebGL(gl) && framebuffer && position);\n\n  const [x, y] = position;\n\n  // Match our picking framebuffer with the size of the canvas drawing buffer\n  framebuffer.resize({width: gl.canvas.width, height: gl.canvas.height});\n\n  // Compensate for devicePixelRatio\n  // Note: this assumes the canvas framebuffer has been matched\n  const dpr = useDevicePixels ? getDevicePixelRatio() : 1;\n  // Reverse the y coordinate\n  const deviceX = x * dpr;\n  const deviceY = gl.canvas.height - y * dpr;\n\n  // return withParameters(gl, {\n  //   // framebuffer,\n  //   // // We are only interested in one pixel, no need to render anything else\n  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}\n  // }, () => {\n  const group = new Group({children: models});\n  return group.traverseReverse(model => {\n\n    if (model.pickable) {\n      // Clear the frame buffer\n      clear(gl, {framebuffer, color: true, depth: true});\n\n      // Render picking colors\n      /* eslint-disable camelcase */\n      model.setUniforms({picking_uActive: 1});\n      model.draw(Object.assign({}, props, {uniforms, parameters, settings, framebuffer, context}));\n      model.setUniforms({picking_uActive: 0});\n\n      // Sample Read color in the central pixel, to be mapped as a picking color\n      const color = framebuffer.readPixels({\n        x: deviceX,\n        y: deviceY,\n        width: 1,\n        height: 1,\n        format: gl.RGBA,\n        type: gl.UNSIGNED_BYTE});\n\n      const isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0;\n\n      // Add the information to the stack\n      if (isPicked) {\n        return {\n          model,\n          color,\n          x,\n          y,\n          deviceX,\n          deviceY\n        };\n      }\n    }\n\n    return null;\n  });\n  // });\n}\n"],"file":"pick-models.js"}