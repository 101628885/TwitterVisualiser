{"version":3,"sources":["../../../src/core/pick-models.js"],"names":["clear","isWebGL","Group","assert","getDevicePixelRatio","window","devicePixelRatio","pickModels","gl","props","models","position","uniforms","parameters","settings","useDevicePixels","framebuffer","context","x","y","resize","width","canvas","height","dpr","deviceX","deviceY","group","children","traverseReverse","model","pickable","color","depth","setUniforms","picking_uActive","draw","Object","assign","readPixels","format","type","isPicked"],"mappings":"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","sourcesContent":["/* global window */\nimport {clear, isWebGL} from '../webgl';\nimport Group from './group';\nimport assert from '../utils/assert';\n\nfunction getDevicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n}\n\nexport default function pickModels(gl, props) {\n  const {\n    models,\n    position,\n    uniforms = {}, // eslint-disable-line\n    parameters = {},\n    settings,\n    useDevicePixels = true,\n    framebuffer,\n    context\n  } = props;\n\n  assert(isWebGL(gl) && framebuffer && position);\n\n  const [x, y] = position;\n\n  // Match our picking framebuffer with the size of the canvas drawing buffer\n  framebuffer.resize({width: gl.canvas.width, height: gl.canvas.height});\n\n  // Compensate for devicePixelRatio\n  // Note: this assumes the canvas framebuffer has been matched\n  const dpr = useDevicePixels ? getDevicePixelRatio() : 1;\n  // Reverse the y coordinate\n  const deviceX = x * dpr;\n  const deviceY = gl.canvas.height - y * dpr;\n\n  // return withParameters(gl, {\n  //   // framebuffer,\n  //   // // We are only interested in one pixel, no need to render anything else\n  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}\n  // }, () => {\n  const group = new Group({children: models});\n  return group.traverseReverse(model => {\n\n    if (model.pickable) {\n      // Clear the frame buffer\n      clear(gl, {framebuffer, color: true, depth: true});\n\n      // Render picking colors\n      /* eslint-disable camelcase */\n      model.setUniforms({picking_uActive: 1});\n      model.draw(Object.assign({}, props, {uniforms, parameters, settings, framebuffer, context}));\n      model.setUniforms({picking_uActive: 0});\n\n      // Sample Read color in the central pixel, to be mapped as a picking color\n      const color = framebuffer.readPixels({\n        x: deviceX,\n        y: deviceY,\n        width: 1,\n        height: 1,\n        format: gl.RGBA,\n        type: gl.UNSIGNED_BYTE});\n\n      const isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0;\n\n      // Add the information to the stack\n      if (isPicked) {\n        return {\n          model,\n          color,\n          x,\n          y,\n          deviceX,\n          deviceY\n        };\n      }\n    }\n\n    return null;\n  });\n  // });\n}\n"],"file":"pick-models.js"}