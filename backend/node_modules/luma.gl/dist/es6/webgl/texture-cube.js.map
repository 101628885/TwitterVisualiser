{"version":3,"sources":["../../../src/webgl/texture-cube.js"],"names":["Texture","assert","FACES","TextureCube","constructor","gl","opts","Object","assign","target","initialize","seal","format","mipmaps","width","height","type","dataFormat","_deduceParameters","_deduceImageSize","data","setCubeMapImageData","generateMipmap","subImage","face","x","y","mipmapLevel","_subImage","pixels","border","bind","texImage2D","index","undefined","activeTexture","bindTexture","handle","unbind"],"mappings":"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","sourcesContent":["import GL from '../constants';\nimport Texture from './texture';\nimport assert from '../utils/assert';\n\nconst FACES = [\n  GL.TEXTURE_CUBE_MAP_POSITIVE_X,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_X,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Y,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Z,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Z\n];\n\nexport default class TextureCube extends Texture {\n  constructor(gl, opts = {}) {\n    super(gl, Object.assign({}, opts, {target: GL.TEXTURE_CUBE_MAP}));\n    this.initialize(opts);\n    Object.seal(this);\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(opts = {}) {\n    const {\n      format = GL.RGBA,\n      mipmaps = true\n    } = opts;\n\n    let {\n      width = 1,\n      height = 1,\n      type = GL.UNSIGNED_BYTE,\n      dataFormat\n    } = opts;\n\n    // Deduce width and height based on one of the faces\n    ({type, dataFormat} = this._deduceParameters({format, type, dataFormat}));\n    ({width, height} = this._deduceImageSize({\n      data: opts[GL.TEXTURE_CUBE_MAP_POSITIVE_X], width, height\n    }));\n\n    // Enforce cube\n    assert(width === height);\n\n    // Temporarily apply any pixel store paramaters and build textures\n    // withParameters(this.gl, opts, () => {\n    //   for (const face of CUBE_MAP_FACES) {\n    //     this.setImageData({\n    //       target: face,\n    //       data: opts[face],\n    //       width, height, format, type, dataFormat, border, mipmaps\n    //     });\n    //   }\n    // });\n\n    this.setCubeMapImageData(opts);\n\n    // Called here so that GL.\n    // TODO - should genMipmap() be called on the cubemap or on the faces?\n    if (mipmaps) {\n      this.generateMipmap(opts);\n    }\n\n    // Store opts for accessors\n    this.opts = opts;\n  }\n\n  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {\n    return this._subImage({target: face, data, x, y, mipmapLevel});\n  }\n\n  /* eslint-disable max-statements, max-len */\n  setCubeMapImageData({\n    width,\n    height,\n    pixels,\n    data,\n    border = 0,\n    format = GL.RGBA,\n    type = GL.UNSIGNED_BYTE,\n    generateMipmap = false\n  }) {\n    const {gl} = this;\n    pixels = pixels || data;\n    this.bind();\n    if (this.width || this.height) {\n      for (const face of FACES) {\n        gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);\n      }\n    } else {\n      for (const face of FACES) {\n        gl.texImage2D(face, 0, format, format, type, pixels[face]);\n      }\n    }\n  }\n\n  bind({index} = {}) {\n    if (index !== undefined) {\n      this.gl.activeTexture(GL.TEXTURE0 + index);\n    }\n    this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, this.handle);\n    return index;\n  }\n\n  unbind() {\n    this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, null);\n    return this;\n  }\n}\n\nTextureCube.FACES = FACES;\n"],"file":"texture-cube.js"}