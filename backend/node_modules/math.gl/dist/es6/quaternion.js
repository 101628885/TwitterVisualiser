import MathArray from './lib/math-array';
import { checkNumber } from './lib/common';
import quat_fromMat3 from 'gl-quat/fromMat3';
import quat_identity from 'gl-quat/identity';
import quat_length from 'gl-quat/length';
import quat_squaredLength from 'gl-quat/squaredLength';
import quat_dot from 'gl-quat/dot';
import quat_rotationTo from 'gl-quat/rotationTo';
import quat_add from 'gl-quat/add';
import quat_calculateW from 'gl-quat/calculateW';
import quat_conjugate from 'gl-quat/conjugate';
import quat_invert from 'gl-quat/invert';
import quat_lerp from 'gl-quat/lerp';
import quat_multiply from 'gl-quat/multiply';
import quat_normalize from 'gl-quat/normalize';
import quat_rotateX from 'gl-quat/rotateX';
import quat_rotateY from 'gl-quat/rotateY';
import quat_rotateZ from 'gl-quat/rotateZ';
import quat_scale from 'gl-quat/scale';
import quat_set from 'gl-quat/set';
import quat_setAxisAngle from 'gl-quat/setAxisAngle';
import quat_slerp from 'gl-quat/slerp';
const IDENTITY_QUATERNION = [0, 0, 0, 1];
export function validateQuaternion(q) {
  return q.length === 4 && Number.isFinite(q[0]) && Number.isFinite(q[1]) && Number.isFinite(q[2]) && Number.isFinite(q[3]);
}
export default class Quaternion extends MathArray {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super();

    if (Array.isArray(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      this.set(x, y, z, w);
    }
  }

  fromMatrix3(m) {
    quat_fromMat3(this, m);
    return this.check();
  }

  fromValues(x, y, z, w) {
    return this.set(x, y, z, w);
  }

  identity() {
    quat_identity(this);
    return this.check();
  }

  get ELEMENTS() {
    return 4;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    return this[0] = checkNumber(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    return this[1] = checkNumber(value);
  }

  get z() {
    return this[2];
  }

  set z(value) {
    return this[2] = checkNumber(value);
  }

  get w() {
    return this[3];
  }

  set w(value) {
    return this[3] = checkNumber(value);
  }

  length() {
    return quat_length(this);
  }

  squaredLength(a) {
    return quat_squaredLength(this);
  }

  dot(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.dot only takes one argument');
    }

    return quat_dot(this, a);
  }

  rotationTo(vectorA, vectorB) {
    quat_rotationTo(this, vectorA, vectorB);
    return this.check();
  }

  add(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.add only takes one argument');
    }

    quat_add(this, a);
    return this.check();
  }

  calculateW() {
    quat_calculateW(this, this);
    return this.check();
  }

  conjugate() {
    quat_conjugate(this, this);
    return this.check();
  }

  invert() {
    quat_invert(this, this);
    return this.check();
  }

  lerp(a, b, t) {
    quat_lerp(this, a, b, t);
    return this.check();
  }

  multiply(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.multiply only takes one argument');
    }

    quat_multiply(this, this, b);
    return this.check();
  }

  normalize() {
    quat_normalize(this, this);
    return this.check();
  }

  rotateX(rad) {
    quat_rotateX(this, this, rad);
    return this.check();
  }

  rotateY(rad) {
    quat_rotateY(this, this, rad);
    return this.check();
  }

  rotateZ(rad) {
    quat_rotateZ(this, this, rad);
    return this.check();
  }

  scale(b) {
    quat_scale(this, this, b);
    return this.check();
  }

  set(i, j, k, l) {
    quat_set(this, i, j, k, l);
    return this.check();
  }

  setAxisAngle(axis, rad) {
    quat_setAxisAngle(this, axis, rad);
    return this.check();
  }

  slerp({
    start = IDENTITY_QUATERNION,
    target,
    ratio
  }) {
    quat_slerp(this, start, target, ratio);
    return this.check();
  }

}
//# sourceMappingURL=quaternion.js.map