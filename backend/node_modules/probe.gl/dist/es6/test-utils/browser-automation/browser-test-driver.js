import BrowserDriver from './browser-driver';
import { COLOR } from '../../lib/utils/color';
import Log from '../../lib/log';
const log = new Log({
  id: 'render-test'
});
let webpackEnv = 'render';

if (process.argv.length >= 3) {
  webpackEnv = process.argv[2];
}

const DEFAULT_CONFIG = {
  title: 'BrowserTest',
  exposeFunction: 'taskComplete',
  parameters: [`--env.${webpackEnv}`]
};
export default class BrowserTestDriver extends BrowserDriver {
  run(config = {}) {
    config = Object.assign(DEFAULT_CONFIG, config);
    const _config = config,
          title = _config.title,
          exposeFunction = _config.exposeFunction;
    this.title = title;
    log.log({
      message: `${title} started. Launching Chromium instance, waiting for ${exposeFunction}...`,
      color: COLOR.YELLOW
    })();
    this.time = Date.now();
    return Promise.resolve().then(_ => this.startServer(config)).then(_ => this.startBrowser()).then(_ => this.newPage()).then(_ => {
      return this.exposeFunction(exposeFunction);
    }).then(resultString => {
      const result = JSON.parse(resultString);
      const ok = result.success === Boolean(result.success) && (!result.failedTest || typeof result.failedTest === 'string');

      if (!ok) {
        throw new Error(`Illegal response "${resultString}" returned from Chrome test script`);
      }

      if (!result.success) {
        throw new Error(result.failedTest || 'Unknown failure');
      }

      this._success();
    }).catch(error => {
      this._failure(error);
    });
  }

  _success() {
    const elapsed = ((Date.now() - this.time) / 1000).toFixed(1);
    log.log({
      message: `${this.title} successfully completed in ${elapsed}s!`,
      color: COLOR.BRIGHT_GREEN
    })();
    this.setShellStatus(true);
    this.exit();
  }

  _failure(error) {
    log.log({
      message: `${this.title} failed: ${error.message}. Keeping browser open to allow debugging.`,
      color: COLOR.BRIGHT_RED
    })();
    this.setShellStatus(false);
  }

}
//# sourceMappingURL=browser-test-driver.js.map