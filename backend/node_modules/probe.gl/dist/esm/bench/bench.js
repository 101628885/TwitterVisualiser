import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { formatSI, rightPad } from '../lib/utils/formatters';
import { global } from '../lib/utils/globals';
import { autobind } from '../lib/utils/autobind';
import LocalStorage from '../lib/utils/local-storage';
import assert from 'assert';

var noop = function noop() {};

var TIME_THRESHOLD_MS = 80;
var TIME_COOLDOWN_MS = 5;
var MIN_ITERATIONS = 1;
export var LOG_ENTRY = {
  GROUP: 'group',
  TEST: 'test',
  COMPLETE: 'complete'
};
var CALIBRATION_TESTS = [{
  id: 'warmup',
  initFunc: noop,
  testFunc: function testFunc() {
    return 100;
  },
  opts: {}
}];

var Bench = function () {
  function Bench() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id,
        log = _ref.log,
        _ref$time = _ref.time,
        time = _ref$time === void 0 ? TIME_THRESHOLD_MS : _ref$time,
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? TIME_COOLDOWN_MS : _ref$delay,
        _ref$minIterations = _ref.minIterations,
        minIterations = _ref$minIterations === void 0 ? MIN_ITERATIONS : _ref$minIterations;

    _classCallCheck(this, Bench);

    if (!log) {
      var markdown = global.probe && global.probe.markdown;
      log = markdown ? logResultsAsMarkdownTable : logResultsAsTree;
    }

    this.id = id;
    this.opts = {
      log: log,
      time: time,
      delay: delay,
      minIterations: minIterations
    };
    this.tests = {};
    this.results = {};
    this.table = {};
    autobind(this);
    Object.seal(this);
  }

  _createClass(Bench, [{
    key: "calibrate",
    value: function calibrate(id, func1, func2, opts) {
      return this;
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var timer = new Date();
      var tests = this.tests,
          onBenchmarkComplete = this.onBenchmarkComplete;
      var promise = runAsyncTests({
        tests: tests,
        onBenchmarkComplete: onBenchmarkComplete
      });
      promise.then(function () {
        var elapsed = (new Date() - timer) / 1000;
        logEntry(_this, {
          entry: LOG_ENTRY.COMPLETE,
          time: elapsed,
          message: 'Complete'
        });

        _this.onSuiteComplete();
      });
      return promise;
    }
  }, {
    key: "group",
    value: function group(id) {
      assert(!this.tests[id], 'tests need unique id strings');
      this.tests[id] = {
        id: id,
        group: true,
        opts: this.opts
      };
      return this;
    }
  }, {
    key: "add",
    value: function add(priority, id, func1, func2) {
      if (typeof priority === 'string') {
        func2 = func1;
        func1 = id;
        id = priority;
        priority = 0;
      }

      assert(id);
      assert(typeof func1 === 'function');
      var initFunc = null;
      var testFunc = func1;

      if (typeof func2 === 'function') {
        initFunc = func1;
        testFunc = func2;
      }

      assert(!this.tests[id], 'tests need unique id strings');
      this.tests[id] = {
        id: id,
        priority: priority,
        initFunc: initFunc,
        testFunc: testFunc,
        opts: this.opts
      };
      return this;
    }
  }, {
    key: "onBenchmarkComplete",
    value: function onBenchmarkComplete(_ref2) {
      var id = _ref2.id,
          time = _ref2.time,
          iterations = _ref2.iterations,
          itersPerSecond = _ref2.itersPerSecond;
      var current = Math.round(iterations / time);
      this.table[id] = {
        percent: '',
        iterations: "".concat(itersPerSecond, "/s"),
        current: current,
        max: ''
      };
    }
  }, {
    key: "onSuiteComplete",
    value: function onSuiteComplete() {
      var localStorage = new LocalStorage({
        id: this.id
      });
      var saved = localStorage.getConfiguration();
      var current = this.updateTable(this.table, saved);
      localStorage.updateConfiguration(current);
      console.table(current);
    }
  }, {
    key: "updateTable",
    value: function updateTable(current, saved) {
      for (var id in this.table) {
        if (saved[id] && saved[id].max !== undefined) {
          current[id].max = Math.max(current[id].current, saved[id].max);
          var delta = current[id].current / saved[id].max;
          current[id].percent = "".concat(Math.round(delta * 100 - 100), "%");
        } else {
          current[id].max = current[id].current;
        }
      }

      return current;
    }
  }]);

  return Bench;
}();

export { Bench as default };

function runCalibrationTests(_ref3) {
  var tests = _ref3.tests;
  var promise = Promise.resolve(true);

  var _loop = function _loop() {
    var test = CALIBRATION_TESTS[_i];
    promise = promise.then(function () {
      return runAsyncTest({
        test: test,
        silent: true
      });
    });
  };

  for (var _i = 0; _i < CALIBRATION_TESTS.length; _i++) {
    _loop();
  }

  return promise;
}

function runAsyncTests(_ref4) {
  var tests = _ref4.tests,
      _ref4$onBenchmarkComp = _ref4.onBenchmarkComplete,
      onBenchmarkComplete = _ref4$onBenchmarkComp === void 0 ? noop : _ref4$onBenchmarkComp;
  var promise = runCalibrationTests({
    tests: tests,
    onBenchmarkComplete: onBenchmarkComplete
  });

  var _loop2 = function _loop2(id) {
    var test = tests[id];
    promise = promise.then(function () {
      return runAsyncTest({
        test: test,
        onBenchmarkComplete: onBenchmarkComplete
      });
    });
  };

  for (var id in tests) {
    _loop2(id);
  }

  return promise;
}

function runAsyncTest(_ref5) {
  var test = _ref5.test,
      onBenchmarkComplete = _ref5.onBenchmarkComplete,
      _ref5$silent = _ref5.silent,
      silent = _ref5$silent === void 0 ? false : _ref5$silent;
  return new Promise(function (resolve) {
    setTimeout(function () {
      try {
        if (test.group) {
          logEntry(test, {
            entry: LOG_ENTRY.GROUP,
            id: test.id,
            message: test.id
          });
        } else {
          var _runBenchTest = runBenchTest(test),
              time = _runBenchTest.time,
              iterations = _runBenchTest.iterations;

          var iterationsPerSecond = iterations / time;
          var itersPerSecond = formatSI(iterationsPerSecond);

          if (!silent) {
            logEntry(test, {
              entry: LOG_ENTRY.TEST,
              id: test.id,
              priority: test.priority,
              itersPerSecond: itersPerSecond,
              time: time,
              message: "".concat(test.id, " ").concat(itersPerSecond, "/s")
            });
          }

          if (onBenchmarkComplete) {
            onBenchmarkComplete({
              id: test.id,
              time: time,
              iterations: iterations,
              iterationsPerSecond: iterationsPerSecond,
              itersPerSecond: itersPerSecond
            });
          }
        }
      } finally {
        resolve(true);
      }
    }, test.opts.delay);
  });
}

function runBenchTest(test) {
  var iterations = test.opts.minIterations / 10;
  var elapsedMillis = 0;

  while (elapsedMillis < test.opts.time) {
    var multiplier = 10;

    if (elapsedMillis > 10) {
      multiplier = test.opts.time / elapsedMillis * 1.25;
    }

    iterations *= multiplier;
    var timer = new Date();
    runBenchTestIterations(test, iterations);
    elapsedMillis = new Date() - timer;
  }

  var time = elapsedMillis / 1000;
  return {
    time: time,
    iterations: iterations
  };
}

function runBenchTestIterations(test, iterations) {
  var testArgs = test.initFunc && test.initFunc();
  var context = test.context,
      testFunc = test.testFunc;

  if (context && testArgs) {
    for (var i = 0; i < iterations; i++) {
      testFunc.call(context, testArgs);
    }
  } else {
    for (var _i2 = 0; _i2 < iterations; _i2++) {
      testFunc.call(context);
    }
  }
}

function logEntry(test, opts) {
  var priority = (global.probe && global.probe.priority) | 10;

  if ((opts.priority | 0) <= priority) {
    test.opts.log(opts);
  }
}

export function logResultsAsMarkdownTable(_ref6) {
  var entry = _ref6.entry,
      id = _ref6.id,
      itersPerSecond = _ref6.itersPerSecond,
      time = _ref6.time;
  var COL1 = 50;
  var COL2 = 12;

  switch (entry) {
    case LOG_ENTRY.GROUP:
      console.log('');
      console.log("| ".concat(rightPad(id, COL1), " | iterations/s |"));
      console.log("| ".concat(rightPad('---', COL1), " | ---          |"));
      break;

    case LOG_ENTRY.TEST:
      console.log("| ".concat(rightPad(id, COL1), " | ").concat(rightPad(itersPerSecond, COL2), " |"));
      break;

    case LOG_ENTRY.COMPLETE:
      console.log('');
      console.log("Completed benchmark in ".concat(time, "s"));
      break;

    default:
  }
}
export function logResultsAsTree(_ref7) {
  var entry = _ref7.entry,
      id = _ref7.id,
      itersPerSecond = _ref7.itersPerSecond,
      time = _ref7.time;

  switch (entry) {
    case LOG_ENTRY.GROUP:
      console.log('');
      console.log("".concat(id));
      break;

    case LOG_ENTRY.TEST:
      console.log("\u251C\u2500 ".concat(id, ": ").concat(itersPerSecond, " iterations/s"));
      break;

    case LOG_ENTRY.COMPLETE:
      console.log('');
      console.log("Completed benchmark in ".concat(time, "s"));
      break;

    default:
  }
}
export function logResultsAsTreeWithElapsed(_ref8) {
  var entry = _ref8.entry,
      id = _ref8.id,
      itersPerSecond = _ref8.itersPerSecond,
      time = _ref8.time;

  switch (entry) {
    case LOG_ENTRY.TEST:
      console.log("\u251C\u2500 ".concat(id, ": ").concat(itersPerSecond, " iterations/s (").concat(time.toFixed(2), "s elapsed)"));
      break;

    default:
      logResultsAsTree({
        entry: entry,
        id: id,
        itersPerSecond: itersPerSecond,
        time: time
      });
  }
}
//# sourceMappingURL=bench.js.map