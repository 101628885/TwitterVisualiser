"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Copyright (c) 2015-2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "#define SHADER_NAME arc-brushing-layer-vertex-shader\n\nconst float N = 49.0;\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec3 instancePickingColors;\nattribute float instanceStrokeWidth;\n\nuniform float numSegments;\nuniform float strokeScale;\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec4 pickedColor;\n\nuniform float enableBrushing;\nuniform float brushSource;\nuniform float brushTarget;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(instancePositions.xy);\n  vec2 target = project_position(instancePositions.zw);\n\n  // if not enabled isPointInRange will always return true\n  float isSourceInBrush = isPointInRange(instancePositions.xy, brushSource);\n  float isTargetInBrush = isPointInRange(instancePositions.zw, brushTarget);\n\n  float isInBrush = float(enableBrushing <= 0. ||\n  (brushSource * isSourceInBrush > 0. || brushTarget * isTargetInBrush > 0.));\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_to_clipspace(vec4(nextPos, 1.0));\n\n  // mix strokeWidth with brush, if not in brush, return 0\n  float strokeWidth = strokeScale * instanceStrokeWidth;\n  float finalWidth = mix(0.0, strokeWidth, isInBrush);\n\n  // extrude\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, finalWidth);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  float picked = isPicked(instancePickingColors);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vec4 finalColor = mix(color, pickedColor / 255., picked);\n\n  vColor = mix(\n    vec4(finalColor.rgb, finalColor.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNrZ2wtbGF5ZXJzL2FyYy1icnVzaGluZy1sYXllci9hcmMtYnJ1c2hpbmctbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcmMtYnJ1c2hpbmctbGF5ZXItdmVydGV4Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBhcmMtYnJ1c2hpbmctbGF5ZXItdmVydGV4LXNoYWRlclxuXG5jb25zdCBmbG9hdCBOID0gNDkuMDtcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVRhcmdldENvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3Ryb2tlV2lkdGg7XG5cbnVuaWZvcm0gZmxvYXQgbnVtU2VnbWVudHM7XG51bmlmb3JtIGZsb2F0IHN0cm9rZVNjYWxlO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWM0IHBpY2tlZENvbG9yO1xuXG51bmlmb3JtIGZsb2F0IGVuYWJsZUJydXNoaW5nO1xudW5pZm9ybSBmbG9hdCBicnVzaFNvdXJjZTtcbnVuaWZvcm0gZmxvYXQgYnJ1c2hUYXJnZXQ7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbmZsb2F0IHBhcmFib2xvaWQodmVjMiBzb3VyY2UsIHZlYzIgdGFyZ2V0LCBmbG9hdCByYXRpbykge1xuXG4gIHZlYzIgeCA9IG1peChzb3VyY2UsIHRhcmdldCwgcmF0aW8pO1xuICB2ZWMyIGNlbnRlciA9IG1peChzb3VyY2UsIHRhcmdldCwgMC41KTtcblxuICBmbG9hdCBkU291cmNlQ2VudGVyID0gZGlzdGFuY2Uoc291cmNlLCBjZW50ZXIpO1xuICBmbG9hdCBkWENlbnRlciA9IGRpc3RhbmNlKHgsIGNlbnRlcik7XG4gIHJldHVybiAoZFNvdXJjZUNlbnRlciArIGRYQ2VudGVyKSAqIChkU291cmNlQ2VudGVyIC0gZFhDZW50ZXIpO1xufVxuXG5mbG9hdCBnZXRTZWdtZW50UmF0aW8oZmxvYXQgaW5kZXgpIHtcbiAgcmV0dXJuIHNtb290aHN0ZXAoMC4wLCAxLjAsIGluZGV4IC8gKG51bVNlZ21lbnRzIC0gMS4wKSk7XG59XG5cbnZlYzMgZ2V0UG9zKHZlYzIgc291cmNlLCB2ZWMyIHRhcmdldCwgZmxvYXQgc2VnbWVudFJhdGlvKSB7XG4gIGZsb2F0IHZlcnRleF9oZWlnaHQgPSBwYXJhYm9sb2lkKHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pO1xuXG4gIHJldHVybiB2ZWMzKFxuICAgIG1peChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvKSxcbiAgICBzcXJ0KG1heCgwLjAsIHZlcnRleF9oZWlnaHQpKVxuICApO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWMyIHNvdXJjZSA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpO1xuICB2ZWMyIHRhcmdldCA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMuencpO1xuXG4gIC8vIGlmIG5vdCBlbmFibGVkIGlzUG9pbnRJblJhbmdlIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlXG4gIGZsb2F0IGlzU291cmNlSW5CcnVzaCA9IGlzUG9pbnRJblJhbmdlKGluc3RhbmNlUG9zaXRpb25zLnh5LCBicnVzaFNvdXJjZSk7XG4gIGZsb2F0IGlzVGFyZ2V0SW5CcnVzaCA9IGlzUG9pbnRJblJhbmdlKGluc3RhbmNlUG9zaXRpb25zLnp3LCBicnVzaFRhcmdldCk7XG5cbiAgZmxvYXQgaXNJbkJydXNoID0gZmxvYXQoZW5hYmxlQnJ1c2hpbmcgPD0gMC4gfHxcbiAgKGJydXNoU291cmNlICogaXNTb3VyY2VJbkJydXNoID4gMC4gfHwgYnJ1c2hUYXJnZXQgKiBpc1RhcmdldEluQnJ1c2ggPiAwLikpO1xuXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xuICBmbG9hdCBzZWdtZW50UmF0aW8gPSBnZXRTZWdtZW50UmF0aW8oc2VnbWVudEluZGV4KTtcblxuICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBwb2ludCwgdXNlIG5leHQgLSBjdXJyZW50IGFzIGRpcmVjdGlvblxuICAvLyBvdGhlcndpc2UgdXNlIGN1cnJlbnQgLSBwcmV2XG4gIGZsb2F0IGluZGV4RGlyID0gbWl4KC0xLjAsIDEuMCwgc3RlcChzZWdtZW50SW5kZXgsIDAuMCkpO1xuICBmbG9hdCBuZXh0U2VnbWVudFJhdGlvID0gZ2V0U2VnbWVudFJhdGlvKHNlZ21lbnRJbmRleCArIGluZGV4RGlyKTtcblxuICB2ZWMzIGN1cnJQb3MgPSBnZXRQb3Moc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbyk7XG4gIHZlYzMgbmV4dFBvcyA9IGdldFBvcyhzb3VyY2UsIHRhcmdldCwgbmV4dFNlZ21lbnRSYXRpbyk7XG4gIHZlYzQgY3VyciA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoY3VyclBvcywgMS4wKSk7XG4gIHZlYzQgbmV4dCA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQobmV4dFBvcywgMS4wKSk7XG5cbiAgLy8gbWl4IHN0cm9rZVdpZHRoIHdpdGggYnJ1c2gsIGlmIG5vdCBpbiBicnVzaCwgcmV0dXJuIDBcbiAgZmxvYXQgc3Ryb2tlV2lkdGggPSBzdHJva2VTY2FsZSAqIGluc3RhbmNlU3Ryb2tlV2lkdGg7XG4gIGZsb2F0IGZpbmFsV2lkdGggPSBtaXgoMC4wLCBzdHJva2VXaWR0aCwgaXNJbkJydXNoKTtcblxuICAvLyBleHRydWRlXG4gIHZlYzIgb2Zmc2V0ID0gZ2V0RXh0cnVzaW9uT2Zmc2V0KChuZXh0Lnh5IC0gY3Vyci54eSkgKiBpbmRleERpciwgcG9zaXRpb25zLnksIGZpbmFsV2lkdGgpO1xuICBnbF9Qb3NpdGlvbiA9IGN1cnIgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xuXG4gIGZsb2F0IHBpY2tlZCA9IGlzUGlja2VkKGluc3RhbmNlUGlja2luZ0NvbG9ycyk7XG5cbiAgdmVjNCBjb2xvciA9IG1peChpbnN0YW5jZVNvdXJjZUNvbG9ycywgaW5zdGFuY2VUYXJnZXRDb2xvcnMsIHNlZ21lbnRSYXRpbykgLyAyNTUuO1xuICB2ZWM0IGZpbmFsQ29sb3IgPSBtaXgoY29sb3IsIHBpY2tlZENvbG9yIC8gMjU1LiwgcGlja2VkKTtcblxuICB2Q29sb3IgPSBtaXgoXG4gICAgdmVjNChmaW5hbENvbG9yLnJnYiwgZmluYWxDb2xvci5hICogb3BhY2l0eSksXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxuICApO1xufVxuYDtcbiJdfQ==